{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py_canoe","text":"<p>Python \ud83d\udc0d Package for controlling Vector CANoe \ud83d\udef6 Tool</p> <p>fork this repo and create pull request to contribute back to this project.</p> <p>for ideas/discussions please create new discussion here</p> <p>create issue or request feature here</p>"},{"location":"#github-releases-link","title":"GitHub Releases \ud83d\udc49 link","text":""},{"location":"#pypi-package-link","title":"PyPi Package \ud83d\udc49 link","text":""},{"location":"002_prerequisites/","title":"Prerequisites","text":"<ul> <li> Python(&gt;=3.9)</li> <li> Vector CANoe software(&gt;=v11)</li> <li> Windows PC(recomended win 10 os)</li> <li> visual studio code</li> </ul>"},{"location":"003_environment_setup/","title":"package environment setup and installation","text":"<p>create python virtual environment</p> <pre><code>python -m venv .venv\n</code></pre> <p>activate virtual environment</p> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>upgrade pip</p> <pre><code>python -m pip install pip --upgrade\n</code></pre> <p>Install py_canoe package</p> <pre><code>pip install py_canoe --upgrade\n</code></pre>"},{"location":"004_usage/","title":"Usage","text":""},{"location":"004_usage/#import-canoe-module","title":"Import CANoe module.","text":"<pre><code># Import CANoe module. Always do this in your root script.\nfrom py_canoe import CANoe\n\n# create CANoe object. arguments are optional. Avoid creating multiple CANoe instances.\ncanoe_inst = CANoe(py_canoe_log_dir=fr'D:\\py_canoe\\py_canoe_log', user_capl_functions=('addition_function', 'hello_world'))\n</code></pre>"},{"location":"004_usage/#example-use-cases","title":"Example use cases","text":""},{"location":"004_usage/#open-canoe-start-measurement-get-version-info-stop-measurement-and-close-canoe-configuration","title":"open CANoe, start measurement, get version info, stop measurement and close canoe configuration","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\ncanoe_version_info = canoe_inst.get_canoe_version_info()\ncanoe_inst.stop_measurement()\ncanoe_inst.quit()\n</code></pre>"},{"location":"004_usage/#restartreset-running-measurement","title":"restart/reset running measurement","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\ncanoe_inst.reset_measurement()\ncanoe_inst.stop_ex_measurement()\n</code></pre>"},{"location":"004_usage/#open-canoe-offline-config-and-startbreakstepresetstop-measurement-in-offline-mode","title":"open CANoe offline config and start/break/step/reset/stop measurement in offline mode","text":"<pre><code>canoe_inst.open(fr'D:\\py_canoe\\demo_cfg\\demo_offline.cfg')\ncanoe_inst.add_offline_source_log_file(fr'D:\\py_canoe\\demo_cfg\\Logs\\demo_log.blf')\ncanoe_inst.start_measurement_in_animation_mode(animation_delay=200)\nwait(1)\ncanoe_inst.break_measurement_in_offline_mode()\nwait(1)\ncanoe_inst.step_measurement_event_in_single_step()\nwait(1)\ncanoe_inst.reset_measurement_in_offline_mode()\nwait(1)\ncanoe_inst.stop_measurement()\nwait(1)\n</code></pre>"},{"location":"004_usage/#getset-canoe-measurement-index","title":"get/set CANoe measurement index","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\nmeas_index_value = canoe_inst.get_measurement_index()\ncanoe_inst.start_measurement()\ncanoe_inst.stop_measurement()\nmeas_index_value = canoe_inst.get_measurement_index()\ncanoe_inst.set_measurement_index(meas_index_value + 1)\nmeas_index_new = canoe_inst.get_measurement_index()\ncanoe_inst.reset_measurement()\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#save-canoe-config-to-a-different-version-with-different-name","title":"save CANoe config to a different version with different name","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.save_configuration_as(path=fr'D:\\py_canoe\\demo_cfg\\demo_v10.cfg', major=10, minor=0, create_dir=True)\n</code></pre>"},{"location":"004_usage/#get-can-bus-statistics-of-can-channel-1","title":"get CAN bus statistics of CAN channel 1","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\nwait(2)\ncanoe_inst.get_can_bus_statistics(channel=1)\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#getset-bus-signal-value-check-signal-state-and-get-signal-full-name","title":"get/set bus signal value, check signal state and get signal full name","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\nwait(1)\nsig_full_name = canoe_inst.get_signal_full_name(bus='CAN', channel=1, message='LightState', signal='FlashLight')\nsig_value = canoe_inst.get_signal_value(bus='CAN', channel=1, message='LightState', signal='FlashLight', raw_value=False)\ncanoe_inst.set_signal_value(bus='CAN', channel=1, message='LightState', signal='FlashLight', value=1, raw_value=False)\nwait(1)\nsig_online_state = canoe_inst.check_signal_online(bus='CAN', channel=1, message='LightState', signal='FlashLight')\nsig_state = canoe_inst.check_signal_state(bus='CAN', channel=1, message='LightState', signal='FlashLight')\nsig_val = canoe_inst.get_signal_value(bus='CAN', channel=1, message='LightState', signal='FlashLight', raw_value=True)\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#clear-write-window-read-text-from-write-window-control-write-window-output-file","title":"clear write window / read text from write window / control write window output file","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.enable_write_window_output_file(fr'{file_path}\\demo_cfg\\Logs\\write_win.txt')\nwait(1)\ncanoe_inst.start_measurement()\ncanoe_inst.clear_write_window_content()\nwait(1)\ncanoe_inst.write_text_in_write_window(\"hello from py_canoe!\")\nwait(1)\ntext = canoe_inst.read_text_from_write_window()\ncanoe_inst.stop_measurement()\ncanoe_inst.disable_write_window_output_file()\nwait(1)\n</code></pre>"},{"location":"004_usage/#switch-between-canoe-desktops","title":"switch between CANoe desktops","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.ui_activate_desktop('Configuration')\n</code></pre>"},{"location":"004_usage/#getset-system-variable-or-define-system-variable","title":"get/set system variable or define system variable","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\nwait(1)\ncanoe_inst.set_system_variable_value('demo::level_two_1::sys_var2', 20)\ncanoe_inst.set_system_variable_value('demo::string_var', 'hey hello this is string variable')\ncanoe_inst.set_system_variable_value('demo::data_var', 'hey hello this is data variable')\ncanoe_inst.set_system_variable_array_values('demo::int_array_var', (00, 11, 22, 33, 44, 55, 66, 77, 88, 99))\nwait(0.1)\nsys_var_val = canoe_inst.get_system_variable_value('demo::level_two_1::sys_var2')\nsys_var_val = canoe_inst.get_system_variable_value('demo::data_var')\ncanoe_inst.stop_measurement()\n# define system variable and use it in measurement\ncanoe_inst.define_system_variable('sys_demo::demo', 1)\ncanoe_inst.save_configuration()\ncanoe_inst.start_measurement()\nwait(1)\nsys_var_val = canoe_inst.get_system_variable_value('sys_demo::demo')\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#send-diagnostic-request-control-tester-present","title":"send diagnostic request, control tester present","text":"<pre><code>canoe_inst.open(fr'D:\\py_canoe\\demo_cfg\\demo_diag.cfg')\ncanoe_inst.start_measurement()\nwait(1)\nresp = canoe_inst.send_diag_request('Door', 'DefaultSession_Start', False)\ncanoe_inst.control_tester_present('Door', False)\nwait(2)\ncanoe_inst.control_tester_present('Door', True)\nwait(5)\nresp = canoe_inst.send_diag_request('Door', '10 02')\ncanoe_inst.control_tester_present('Door', False)\nwait(2)\nresp = canoe_inst.send_diag_request('Door', '10 03', return_sender_name=True)\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#set-replay-block-source-file-control-replay-block-start-stop","title":"set replay block source file / control replay block start stop","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\nwait(1)\ncanoe_inst.set_replay_block_file(block_name='DemoReplayBlock', recording_file_path=fr'D:\\py_canoe\\demo_cfg\\Logs\\demo_log.blf')\nwait(1)\ncanoe_inst.control_replay_block(block_name='DemoReplayBlock', start_stop=True)\nwait(2)\ncanoe_inst.control_replay_block(block_name='DemoReplayBlock', start_stop=False)\nwait(1)\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#compile-capl-nodes-and-call-capl-function","title":"compile CAPL nodes and call capl function","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.compile_all_capl_nodes()\ncanoe_inst.start_measurement()\nwait(1)\ncanoe_inst.call_capl_function('addition_function', 100, 200)\ncanoe_inst.call_capl_function('hello_world')\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#execute-test-setup-test-module-test-environment","title":"execute test setup test module / test environment","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\nwait(1)\ncanoe_inst.execute_all_test_modules_in_test_env(demo_test_environment)\ncanoe_inst.execute_test_module('demo_test_node_002')\nwait(1)\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"004_usage/#getset-environment-variable-value","title":"get/set environment variable value","text":"<pre><code>canoe_inst.open(canoe_cfg=fr'D:\\py_canoe\\demo_cfg\\demo_dev.cfg', visible=True, auto_save=False, prompt_user=False)\ncanoe_inst.start_measurement()\nwait(1)\ncanoe_inst.set_environment_variable_value('int_var', 123.12)\ncanoe_inst.set_environment_variable_value('float_var', 111.123)\ncanoe_inst.set_environment_variable_value('string_var', 'this is string variable')\ncanoe_inst.set_environment_variable_value('data_var', (1, 2, 3, 4, 5, 6, 7))\nvar_value = canoe_inst.get_environment_variable_value('int_var')\nvar_value = canoe_inst.get_environment_variable_value('float_var')\nvar_value = canoe_inst.get_environment_variable_value('string_var')\nvar_value = canoe_inst.get_environment_variable_value('data_var')\nwait(1)\ncanoe_inst.stop_measurement()\n</code></pre>"},{"location":"999_reference/","title":"reference","text":"<p>Python package for controlling Vector CANoe tool</p>"},{"location":"999_reference/#src.py_canoe.CANoe","title":"<code>CANoe</code>","text":"<p>The CANoe class represents the CANoe application. The CANoe class is the foundation for the object hierarchy. You can reach all other methods from the CANoe class instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example to open CANoe configuration, start measurement, stop measurement and close configuration.\n&gt;&gt;&gt; canoe_inst = CANoe(py_canoe_log_dir=r'D:\\.py_canoe')\n&gt;&gt;&gt; canoe_inst.open(r'D:\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(10)\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n&gt;&gt;&gt; canoe_inst.quit()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>class CANoe:\n    r\"\"\"The CANoe class represents the CANoe application.\n    The CANoe class is the foundation for the object hierarchy.\n    You can reach all other methods from the CANoe class instance.\n\n    Examples:\n        &gt;&gt;&gt; # Example to open CANoe configuration, start measurement, stop measurement and close configuration.\n        &gt;&gt;&gt; canoe_inst = CANoe(py_canoe_log_dir=r'D:\\.py_canoe')\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(10)\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n        &gt;&gt;&gt; canoe_inst.quit()\n    \"\"\"\n\n    def __init__(self, py_canoe_log_dir='', user_capl_functions=tuple()):\n        \"\"\"\n        Args:\n            py_canoe_log_dir (str): directory to store py_canoe log. example 'D:\\\\.py_canoe'\n            user_capl_functions (tuple): user defined CAPL functions to access. on measurement init these functions will be initialized.\n        \"\"\"\n        pcl = PyCanoeLogger(py_canoe_log_dir)\n        self.log = pcl.log\n        self.application: Application\n        self.__diag_devices = dict()\n        self.__test_environments = dict()\n        self.__test_modules = list()\n        self.__replay_blocks = dict()\n        self.user_capl_function_names = user_capl_functions\n\n    def open(self, canoe_cfg: str, visible=True, auto_save=False, prompt_user=False) -&gt; None:\n        r\"\"\"Loads CANoe configuration.\n\n        Args:\n            canoe_cfg (str): The complete path for the CANoe configuration.\n            visible (bool): True if you want to see CANoe UI. Defaults to True.\n            auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n        \"\"\"\n        pythoncom.CoInitialize()\n        self.application = Application(self.user_capl_function_names)\n        self.application.visible = visible\n        self.application.open(path=canoe_cfg, auto_save=auto_save, prompt_user=prompt_user)\n        self.__diag_devices = self.application.networks.fetch_all_diag_devices()\n        self.__test_environments = self.application.configuration.get_all_test_setup_environments()\n        self.__test_modules = self.application.configuration.get_all_test_modules_in_test_environments()\n        self.__replay_blocks = self.application.configuration.simulation_setup.replay_collection.fetch_replay_blocks()\n\n    def new(self, auto_save=False, prompt_user=False) -&gt; None:\n        \"\"\"Creates a new configuration.\n\n        Args:\n            auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n        \"\"\"\n        self.application.new(auto_save, prompt_user)\n\n    def quit(self):\n        r\"\"\"Quits CANoe without saving changes in the configuration.\n        \"\"\"\n        self.application.quit()\n\n    def start_measurement(self, timeout=60) -&gt; bool:\n        r\"\"\"Starts the measurement.\n\n        Args:\n            timeout (int, optional): measurement start/stop event timeout in seconds. Defaults to 60.\n\n        Returns:\n            True if measurement started. else False.\n        \"\"\"\n        self.application.measurement.meas_start_stop_timeout = timeout\n        return self.application.measurement.start()\n\n    def stop_measurement(self, timeout=60) -&gt; bool:\n        r\"\"\"Stops the measurement.\n\n        Args:\n            timeout (int, optional): measurement start/stop event timeout in seconds. Defaults to 60.\n\n        Returns:\n            True if measurement stopped. else False.\n        \"\"\"\n        self.application.measurement.meas_start_stop_timeout = timeout\n        return self.application.measurement.stop()\n\n    def stop_ex_measurement(self, timeout=60) -&gt; bool:\n        r\"\"\"StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.\n\n        Args:\n            timeout (int, optional): measurement start/stop event timeout in seconds. Defaults to 60.\n\n        Returns:\n            True if measurement stopped. else False.\n        \"\"\"\n        self.application.measurement.meas_start_stop_timeout = timeout\n        return self.application.measurement.stop_ex()\n\n    def reset_measurement(self) -&gt; bool:\n        r\"\"\"reset the measurement.\n\n        Returns:\n            Measurement running status(True/False).\n        \"\"\"\n        if self.application.measurement.running:\n            self.application.measurement.stop()\n        self.application.measurement.start()\n        self.log.info(f'Resetted measurement.')\n        return self.application.measurement.running\n\n    def get_measurement_running_status(self) -&gt; bool:\n        r\"\"\"Returns the running state of the measurement.\n\n        Returns:\n            True if The measurement is running.\n            False if The measurement is not running.\n        \"\"\"\n        self.log.info(f'CANoe Measurement Running Status = {self.application.measurement.running}')\n        return self.application.measurement.running\n\n    def add_offline_source_log_file(self, absolute_log_file_path: str) -&gt; bool:\n        r\"\"\"this method adds offline source log file.\n\n        Args:\n            absolute_log_file_path (str): absolute path of offline source log file.\n\n        Returns:\n            bool: returns True if log file added or already available. False if log file not available.\n        \"\"\"\n        if os.path.isfile(absolute_log_file_path):\n            offline_sources = self.application.configuration.com_obj.OfflineSetup.Source.Sources\n            file_already_added = any([file == absolute_log_file_path for file in offline_sources])\n            if file_already_added:\n                self.log.info(f'offline logging file ({absolute_log_file_path}) already added.')\n            else:\n                offline_sources.Add(absolute_log_file_path)\n                self.log.info(f'added offline logging file ({absolute_log_file_path})')\n            return True\n        else:\n            self.log.info(f'invalid logging file ({absolute_log_file_path}). Failed to add.')\n            return False\n\n    def start_measurement_in_animation_mode(self, animation_delay=100) -&gt; None:\n        r\"\"\"Starts the measurement in Animation mode.\n\n        Args:\n            animation_delay (int): The animation delay during the measurement in Offline Mode.\n        \"\"\"\n        self.application.measurement.animation_delay = animation_delay\n        self.application.measurement.animate()\n\n    def break_measurement_in_offline_mode(self) -&gt; None:\n        r\"\"\"Interrupts the playback in Offline mode.\n        \"\"\"\n        self.application.measurement.break_offline_mode()\n\n    def reset_measurement_in_offline_mode(self) -&gt; None:\n        r\"\"\"Resets the measurement in Offline mode.\n        \"\"\"\n        self.application.measurement.reset_offline_mode()\n\n    def step_measurement_event_in_single_step(self) -&gt; None:\n        r\"\"\"Processes a measurement event in single step.\n        \"\"\"\n        self.application.measurement.step()\n\n    def get_measurement_index(self) -&gt; int:\n        r\"\"\"gets the measurement index for the next measurement.\n\n        Returns:\n            Measurement Index.\n        \"\"\"\n        self.log.info(f'measurement_index value = {self.application.measurement.measurement_index}')\n        return self.application.measurement.measurement_index\n\n    def set_measurement_index(self, index: int) -&gt; int:\n        r\"\"\"sets the measurement index for the next measurement.\n\n        Args:\n            index (int): index value to set.\n\n        Returns:\n            Measurement Index value.\n        \"\"\"\n        self.application.measurement.measurement_index = index\n        return self.application.measurement.measurement_index\n\n    def save_configuration(self) -&gt; bool:\n        r\"\"\"Saves the configuration.\n\n        Returns:\n            True if configuration saved. else False.\n        \"\"\"\n        return self.application.configuration.save()\n\n    def save_configuration_as(self, path: str, major: int, minor: int, create_dir=True) -&gt; bool:\n        r\"\"\"Saves the configuration as a different CANoe version.\n\n        Args:\n            path (str): The complete file name.\n            major (int): The major version number of the target version.\n            minor (int): The minor version number of the target version.\n            create_dir (bool): create directory if not available. default value True.\n\n        Returns:\n            True if configuration saved. else False.\n        \"\"\"\n        config_path = '\\\\'.join(path.split('\\\\')[:-1])\n        if not os.path.exists(config_path) and create_dir:\n            os.makedirs(config_path, exist_ok=True)\n        if os.path.exists(config_path):\n            self.application.configuration.save_as(path, major, minor, False)\n            return self.application.configuration.saved\n        else:\n            self.log.info(f'tried creating {path}. but {config_path} directory not found.')\n            return False\n\n    def get_can_bus_statistics(self, channel: int) -&gt; dict:\n        r\"\"\"Returns CAN Bus Statistics.\n\n        Args:\n            channel (int): The channel of the statistic that is to be returned.\n\n        Returns:\n            CAN bus statistics.\n        \"\"\"\n        conf_obj = self.application.configuration\n        bus_types = {'CAN': 1, 'J1939': 2, 'TTP': 4, 'LIN': 5, 'MOST': 6, 'Kline': 14}\n        bus_statistics_obj = conf_obj.com_obj.OnlineSetup.BusStatistics.BusStatistic(bus_types['CAN'], channel)\n        statistics_info = {\n            # The bus load\n            'bus_load': bus_statistics_obj.BusLoad,\n            # The controller status\n            'chip_state': bus_statistics_obj.ChipState,\n            # The number of Error Frames per second\n            'error': bus_statistics_obj.Error,\n            # The total number of Error Frames\n            'error_total': bus_statistics_obj.ErrorTotal,\n            # The number of messages with extended identifier per second\n            'extended': bus_statistics_obj.Extended,\n            # The total number of messages with extended identifier\n            'extended_total': bus_statistics_obj.ExtendedTotal,\n            # The number of remote messages with extended identifier per second\n            'extended_remote': bus_statistics_obj.ExtendedRemote,\n            # The total number of remote messages with extended identifier\n            'extended_remote_total': bus_statistics_obj.ExtendedRemoteTotal,\n            # The number of overload frames per second\n            'overload': bus_statistics_obj.Overload,\n            # The total number of overload frames\n            'overload_total': bus_statistics_obj.OverloadTotal,\n            # The maximum bus load in 0.01 %\n            'peak_load': bus_statistics_obj.PeakLoad,\n            # Returns the current number of the Rx error counter\n            'rx_error_count': bus_statistics_obj.RxErrorCount,\n            # The number of messages with standard identifier per second\n            'standard': bus_statistics_obj.Standard,\n            # The total number of remote messages with standard identifier\n            'standard_total': bus_statistics_obj.StandardTotal,\n            # The number of remote messages with standard identifier per second\n            'standard_remote': bus_statistics_obj.StandardRemote,\n            # The total number of remote messages with standard identifier\n            'standard_remote_total': bus_statistics_obj.StandardRemoteTotal,\n            # The current number of the Tx error counter\n            'tx_error_count': bus_statistics_obj.TxErrorCount,\n        }\n        self.log.info(f'CAN Bus Statistics: {statistics_info}.')\n        return statistics_info\n\n    def get_canoe_version_info(self) -&gt; dict:\n        r\"\"\"The Version class represents the version of the CANoe application.\n\n        Returns:\n            \"full_name\" - The complete CANoe version.\n            \"name\" - The CANoe version.\n            \"build\" - The build number of the CANoe application.\n            \"major\" - The major version number of the CANoe application.\n            \"minor\" - The minor version number of the CANoe application.\n            \"patch\" - The patch number of the CANoe application.\n        \"\"\"\n        ver_obj = self.application.version\n        version_info = {'full_name': ver_obj.full_name,\n                        'name': ver_obj.name,\n                        'build': ver_obj.build,\n                        'major': ver_obj.major,\n                        'minor': ver_obj.minor,\n                        'patch': ver_obj.patch}\n        self.log.info('&gt; CANoe Application.Version &lt;'.center(100, '='))\n        for k, v in version_info.items():\n            self.log.info(f'{k:&lt;10}: {v}')\n        self.log.info(''.center(100, '='))\n        return version_info\n\n    def get_bus_databases_info(self, bus: str) -&gt; dict:\n        \"\"\"returns bus database info(path, channel, full_name).\n\n        Args:\n            bus (str): bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n\n        Returns:\n            bus database info {'path': 'value', 'channel': 'value', 'full_name': 'value'}\n        \"\"\"\n        dbcs_info = dict()\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        db_objects = bus_obj.database_objects()\n        for db_object in db_objects.values():\n            dbcs_info[db_object.Name] = {'path': db_object.Path, 'channel': db_object.Channel, 'full_name': db_object.FullName}\n        self.log.info(f'{bus} bus databases info -&gt; {dbcs_info}.')\n        return dbcs_info\n\n    def get_bus_nodes_info(self, bus: str) -&gt; dict:\n        \"\"\"returns bus nodes info(path, full_name, active).\n\n        Args:\n            bus (str): bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n\n        Returns:\n            bus nodes info {'path': 'value', 'full_name': 'value', 'active': 'value'}\n        \"\"\"\n        nodes_info = dict()\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        node_objects = bus_obj.node_objects()\n        for n_object in node_objects.values():\n            nodes_info[n_object.Name] = {'path': n_object.Path, 'full_name': n_object.FullName, 'active': n_object.Active}\n        self.log.info(f'{bus} bus nodes info -&gt; {nodes_info}.')\n        return nodes_info\n\n    def get_signal_value(self, bus: str, channel: int, message: str, signal: str, raw_value=False) -&gt; Union[float, int]:\n        r\"\"\"get_signal_value Returns a Signal value.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Returns:\n            signal value.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_signal(channel, message, signal)\n        signal_value = bus_obj.signal_get_raw_value(sig_obj) if raw_value else bus_obj.signal_get_value(sig_obj)\n        self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n        return signal_value\n\n    def set_signal_value(self, bus: str, channel: int, message: str, signal: str, value: int, raw_value=False) -&gt; None:\n        r\"\"\"set_signal_value sets a value to Signal. Works only when messages are sent using CANoe IL.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            value (Union[float, int]): signal value.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_signal(channel, message, signal)\n        if raw_value:\n            bus_obj.signal_set_raw_value(sig_obj, value)\n        else:\n            bus_obj.signal_set_value(sig_obj, value)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n\n    def get_signal_full_name(self, bus: str, channel: int, message: str, signal: str) -&gt; str:\n        \"\"\"Determines the fully qualified name of a signal.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_signal(channel, message, signal)\n        signal_fullname = bus_obj.signal_full_name(sig_obj)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) full name = {signal_fullname}.')\n        return signal_fullname\n\n    def check_signal_online(self, bus: str, channel: int, message: str, signal: str) -&gt; bool:\n        r\"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            TRUE if the measurement is running and the signal has been received. FALSE if not.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_signal(channel, message, signal)\n        sig_online_status = bus_obj.signal_is_online(sig_obj)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) online status = {sig_online_status}.')\n        return sig_online_status\n\n    def check_signal_state(self, bus: str, channel: int, message: str, signal: str) -&gt; int:\n        r\"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            State of the signal.\n                0- The default value of the signal is returned. \n                1- The measurement is not running; the value set by the application is returned. \n                2- The measurement is not running; the value of the last measurement is returned. \n                3- The signal has been received in the current measurement; the current value is returned.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_signal(channel, message, signal)\n        sig_state = bus_obj.signal_state(sig_obj)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) state = {sig_state}.')\n        return sig_state\n\n    def get_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int, raw_value=False) -&gt; Union[float, int]:\n        r\"\"\"get_j1939_signal Returns a Signal object.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Returns:\n            signal value.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n        signal_value = bus_obj.signal_get_raw_value(sig_obj) if raw_value else bus_obj.signal_get_value(sig_obj)\n        self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n        return signal_value\n\n    def set_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int, value: Union[float, int], raw_value=False) -&gt; None:\n        r\"\"\"get_j1939_signal Returns a Signal object.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n            value (Union[float, int]): signal value.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Returns:\n            signal value.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n        if raw_value:\n            bus_obj.signal_set_raw_value(sig_obj, value)\n        else:\n            bus_obj.signal_set_value(sig_obj, value)\n        self.log.info(f'signal value set to {value}.')\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n\n    def get_j1939_signal_full_name(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; str:\n        \"\"\"Determines the fully qualified name of a signal.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n\n        Returns:\n            str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n        signal_fullname = bus_obj.signal_full_name(sig_obj)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) full name = {signal_fullname}.')\n        return signal_fullname\n\n    def check_j1939_signal_online(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; bool:\n        \"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n\n        Returns:\n            bool: TRUE: if the measurement is running and the signal has been received. FALSE: if not.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n        signal_online_status = bus_obj.signal_is_online(sig_obj)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) online status = {signal_online_status}.')\n        return signal_online_status\n\n    def check_j1939_signal_state(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; int:\n        \"\"\"Returns the state of the signal.\n\n        Returns:\n            int: State of the signal.\n                possible values are:\n                    0: The default value of the signal is returned.\n                    1: The measurement is not running; the value set by the application is returned.\n                    3: The signal has been received in the current measurement; the current value is returned.\n        \"\"\"\n        bus_obj = self.application.bus\n        if bus_obj.bus_type != bus:\n            bus_obj.reinit_bus(bus_type=bus)\n        sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n        signal_state = bus_obj.signal_state(sig_obj)\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) state = {signal_state}.')\n        return signal_state\n\n    def ui_activate_desktop(self, name: str) -&gt; None:\n        r\"\"\"Activates the desktop with the given name.\n\n        Args:\n            name (str): The name of the desktop to be activated.\n        \"\"\"\n        self.application.ui.activate_desktop(name)\n\n    def ui_open_baudrate_dialog(self) -&gt; None:\n        r\"\"\"opens the dialog for configuring the bus parameters. Make sure Measurement stopped when using this method.\n        \"\"\"\n        self.application.ui.open_baudrate_dialog()\n\n    def write_text_in_write_window(self, text: str) -&gt; None:\n        r\"\"\"Outputs a line of text in the Write Window.\n        Args:\n            text (str): The text.\n        \"\"\"\n        self.application.ui.write.output(text)\n\n    def read_text_from_write_window(self) -&gt; str:\n        r\"\"\"read the text contents from Write Window.\n\n        Returns:\n            The text content.\n        \"\"\"\n        return self.application.ui.write.text\n\n    def clear_write_window_content(self) -&gt; None:\n        r\"\"\"Clears the contents of the Write Window.\n        \"\"\"\n        self.application.ui.write.clear()\n\n    def copy_write_window_content(self) -&gt; None:\n        r\"\"\"Copies the contents of the Write Window to the clipboard.\n        \"\"\"\n        self.application.ui.write.copy()\n\n    def enable_write_window_output_file(self, output_file: str, tab_index=None) -&gt; None:\n        r\"\"\"Enables logging of all outputs of the Write Window in the output file.\n\n        Args:\n            output_file (str): The complete path of the output file.\n            tab_index (int, optional): The index of the page, for which logging of the output is to be activated. Defaults to None.\n        \"\"\"\n        self.application.ui.write.enable_output_file(output_file, tab_index)\n\n    def disable_write_window_output_file(self, tab_index=None) -&gt; None:\n        r\"\"\"Disables logging of all outputs of the Write Window.\n\n        Args:\n            tab_index (int, optional): The index of the page, for which logging of the output is to be activated. Defaults to None.\n        \"\"\"\n        self.application.ui.write.disable_output_file(tab_index)\n\n    def define_system_variable(self, sys_var_name: str, value: Union[int, float, str]) -&gt; object:\n        r\"\"\"define_system_variable Create a system variable with an initial value\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n            value (Union[int, float, str]): variable value. Default value 0.\n\n        Returns:\n            object: The new Variable object.\n        \"\"\"\n        namespace_name = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        new_var_com_obj = None\n        try:\n            self.application.system.namespaces.add(namespace_name)\n            namespaces = self.application.system.namespaces.fetch_namespaces()\n            namespace = namespaces[namespace_name]\n            new_var_com_obj = namespace.variables.add(variable_name, value)\n            self.log.info(f'system variable({sys_var_name}) created and value set to {value}.')\n        except Exception as e:\n            self.log.info(f'failed to create system variable({sys_var_name}). {e}')\n        return new_var_com_obj\n\n    def get_system_variable_value(self, sys_var_name: str) -&gt; Union[int, float, str, tuple, None]:\n        r\"\"\"get_system_variable_value Returns a system variable value.\n\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n\n        Returns:\n            System Variable value.\n        \"\"\"\n        namespace = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        return_value = None\n        try:\n            namespace_com_object = self.application.system.com_obj.Namespaces(namespace)\n            variable_com_object = namespace_com_object.Variables(variable_name)\n            return_value = variable_com_object.Value\n            self.log.info(f'system variable({sys_var_name}) value &lt;- {return_value}.')\n        except Exception as e:\n            self.log.info(f'failed to get system variable({sys_var_name}) value. {e}')\n        return return_value\n\n    def set_system_variable_value(self, sys_var_name: str, value: Union[int, float, str]) -&gt; None:\n        r\"\"\"set_system_variable_value sets a value to system variable.\n\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\".\n            value (Union[int, float, str]): variable value. supported CAPL system variable data types integer, double, string and data.\n        \"\"\"\n        namespace = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        try:\n            namespace_com_object = self.application.system.com_obj.Namespaces(namespace)\n            variable_com_object = namespace_com_object.Variables(variable_name)\n            if isinstance(variable_com_object.Value, int):\n                variable_com_object.Value = int(value)\n            elif isinstance(variable_com_object.Value, float):\n                variable_com_object.Value = float(value)\n            else:\n                variable_com_object.Value = value\n            self.log.info(f'system variable({sys_var_name}) value set to -&gt; {value}.')\n        except Exception as e:\n            self.log.info(f'failed to set system variable({sys_var_name}) value. {e}')\n\n    def set_system_variable_array_values(self, sys_var_name: str, value: tuple, index=0) -&gt; None:\n        r\"\"\"set_system_variable_array_values sets array of values to system variable.\n\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n            value (tuple): variable values. supported integer array or double array. please always give only one type.\n            index (int): value of index where values will start updating. Defaults to 0.\n        \"\"\"\n        namespace = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        try:\n            namespace_com_object = self.application.system.com_obj.Namespaces(namespace)\n            variable_com_object = namespace_com_object.Variables(variable_name)\n            existing_variable_value = list(variable_com_object.Value)\n            if (index + len(value)) &lt;= len(existing_variable_value):\n                final_value = existing_variable_value\n                if isinstance(existing_variable_value[0], float):\n                    final_value[index: index + len(value)] = (float(v) for v in value)\n                else:\n                    final_value[index: index + len(value)] = value\n                variable_com_object.Value = tuple(final_value)\n                wait(0.1)\n                self.log.info(f'system variable({sys_var_name}) value set to -&gt; {variable_com_object.Value}.')\n            else:\n                self.log.info(\n                    f'failed to set system variable({sys_var_name}) value. check variable length and index value.')\n        except Exception as e:\n            self.log.info(f'failed to set system variable({sys_var_name}) value. {e}')\n\n    def send_diag_request(self, diag_ecu_qualifier_name: str, request: str, request_in_bytes=True, return_sender_name=False) -&gt; Union[str, dict]:\n        r\"\"\"The send_diag_request method represents the query of a diagnostic tester (client) to an ECU (server) in CANoe.\n\n        Args:\n            diag_ecu_qualifier_name (str): Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".\n            request (str): Diagnostic request in bytes or diagnostic request qualifier name.\n            request_in_bytes (bool): True if Diagnostic request is bytes. False if you are using Qualifier name. Default is True.\n            return_sender_name (bool): True if you user want response along with response sender name in dictionary. Default is False.\n\n        Returns:\n            diagnostic response stream. Ex- \"50 01 00 00 00 00\" or {'Door': \"50 01 00 00 00 00\"}\n        \"\"\"\n        diag_response_data = \"\"\n        diag_response_including_sender_name = {}\n        try:\n            if diag_ecu_qualifier_name in self.__diag_devices.keys():\n                self.log.info(f'{diag_ecu_qualifier_name}: Diagnostic Request --&gt; {request}')\n                if request_in_bytes:\n                    diag_req = self.__diag_devices[diag_ecu_qualifier_name].create_request_from_stream(request)\n                else:\n                    diag_req = self.__diag_devices[diag_ecu_qualifier_name].create_request(request)\n                diag_req.send()\n                while diag_req.pending:\n                    wait(0.1)\n                diag_req_responses = diag_req.responses\n                if len(diag_req_responses) == 0:\n                    self.log.info(\"Diagnostic Response Not Received.\")\n                else:\n                    for diag_res in diag_req_responses:\n                        diag_response_data = diag_res.stream\n                        diag_response_including_sender_name[diag_res.sender] = diag_response_data\n                        if diag_res.positive:\n                            self.log.info(f\"{diag_res.sender}: Diagnostic Response +ve &lt;-- {diag_response_data}\")\n                        else:\n                            self.log.info(f\"{diag_res.Sender}: Diagnostic Response -ve &lt;-- {diag_response_data}\")\n            else:\n                self.log.info(\n                    f'Diagnostic ECU qualifier({diag_ecu_qualifier_name}) not available in loaded CANoe config.')\n        except Exception as e:\n            self.log.info(f'failed to send diagnostic request({request}). {e}')\n        return diag_response_including_sender_name if return_sender_name else diag_response_data\n\n    def control_tester_present(self, diag_ecu_qualifier_name: str, value: bool) -&gt; None:\n        \"\"\"Starts/Stops sending autonomous/cyclical Tester Present requests to the ECU.\n\n        Args:\n            diag_ecu_qualifier_name (str): Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".\n            value (bool): True - activate tester present. False - deactivate tester present.\n        \"\"\"\n        if diag_ecu_qualifier_name in self.__diag_devices.keys():\n            diag_device = self.__diag_devices[diag_ecu_qualifier_name]\n            if diag_device.tester_present_status != value:\n                if value:\n                    diag_device.start_tester_present()\n                    self.log.info(f'{diag_ecu_qualifier_name}: started tester present')\n                else:\n                    diag_device.stop_tester_present()\n                    self.log.info(f'{diag_ecu_qualifier_name}: stopped tester present')\n                wait(.1)\n            else:\n                self.log.info(f'{diag_ecu_qualifier_name}: tester present already set to {value}')\n        else:\n            self.log.info(f'diag ECU qualifier \"{diag_ecu_qualifier_name}\" not available in configuration.')\n\n    def set_replay_block_file(self, block_name: str, recording_file_path: str) -&gt; None:\n        r\"\"\"Method for setting CANoe replay block file.\n\n        Args:\n            block_name: CANoe replay block name\n            recording_file_path: CANoe replay recording file including path.\n        \"\"\"\n        replay_blocks = self.__replay_blocks\n        if block_name in replay_blocks.keys():\n            replay_block = replay_blocks[block_name]\n            replay_block.path = recording_file_path\n            self.log.info(f'Replay block \"{block_name}\" updated with \"{recording_file_path}\" path.')\n        else:\n            self.log.warning(f'Replay block \"{block_name}\" not available.')\n\n    def control_replay_block(self, block_name: str, start_stop: bool) -&gt; None:\n        r\"\"\"Method for setting CANoe replay block file.\n\n        Args:\n            block_name (str): CANoe replay block name\n            start_stop (bool): True to start replay block. False to Stop.\n        \"\"\"\n        replay_blocks = self.__replay_blocks\n        if block_name in replay_blocks.keys():\n            replay_block = replay_blocks[block_name]\n            if start_stop:\n                replay_block.start()\n            else:\n                replay_block.stop()\n            self.log.info(f'Replay block \"{block_name}\" {\"Started\" if start_stop else \"Stopped\"}.')\n        else:\n            self.log.warning(f'Replay block \"{block_name}\" not available.')\n\n    def compile_all_capl_nodes(self) -&gt; dict:\n        r\"\"\"compiles all CAPL, XML and .NET nodes.\n        \"\"\"\n        capl_obj = self.application.capl\n        capl_obj.compile()\n        wait(1)\n        compile_result = capl_obj.compile_result()\n        self.log.info(f'compiled all CAPL nodes successfully. result={compile_result[\"result\"]}')\n        return compile_result\n\n    def call_capl_function(self, name: str, *arguments) -&gt; bool:\n        r\"\"\"Calls a CAPL function.\n        Please note that the number of parameters must agree with that of the CAPL function.\n        not possible to read return value of CAPL function at the moment. only execution status is returned.\n\n        Args:\n            name (str): The name of the CAPL function. Please make sure this name is already passed as argument during CANoe instance creation. see example for more info.\n            arguments (tuple): Function parameters p1\u2026p10 (optional).\n\n        Returns:\n            bool: CAPL function execution status. True-success, False-failed.\n        \"\"\"\n        capl_obj = self.application.capl\n        exec_sts = capl_obj.call_capl_function(self.application.measurement.user_capl_function_obj_dict[name], *arguments)\n        self.log.info(f'triggered capl function({name}). execution status = {exec_sts}.')\n        return exec_sts\n\n    def get_test_environments(self) -&gt; dict:\n        \"\"\"returns dictionary of test environment names and class.\n        \"\"\"\n        return self.__test_environments\n\n    def get_test_modules(self, test_env_name: str) -&gt; dict:\n        \"\"\"returns dictionary of test module names and class.\n\n        Args:\n            test_env_name (str): test environment name. avoid duplicate test environment names in CANoe configuration.\n        \"\"\"\n        test_environments = self.get_test_environments()\n        if len(test_environments) &gt; 0:\n            if test_env_name in test_environments.keys():\n                return test_environments[test_env_name].get_all_test_modules()\n            else:\n                self.log.info(f'\"{test_env_name}\" not found in configuration.')\n                return {}\n        else:\n            self.log.info(f'Zero test environments found in configuration. Not possible to fetch test modules.')\n            return {}\n\n    def execute_test_module(self, test_module_name: str) -&gt; int:\n        \"\"\"use this method to execute test module.\n\n        Args:\n            test_module_name (str): test module name. avoid duplicate test module names in CANoe configuration.\n\n        Returns:\n            int: test module execution verdict. 0 ='VerdictNotAvailable', 1 = 'VerdictPassed', 2 = 'VerdictFailed',\n        \"\"\"\n        test_verdict = {0: 'NotAvailable',\n                        1: 'Passed',\n                        2: 'Failed',\n                        3: 'None (not available for test modules)',\n                        4: 'Inconclusive (not available for test modules)',\n                        5: 'ErrorInTestSystem (not available for test modules)', }\n        execution_result = 0\n        test_module_found = False\n        test_env_name = ''\n        for tm in self.__test_modules:\n            if tm['name'] == test_module_name:\n                test_module_found = True\n                tm_obj = tm['object']\n                test_env_name = tm['environment']\n                self.log.info(f'test module \"{test_module_name}\" found in \"{test_env_name}\"')\n                tm_obj.start()\n                tm_obj.wait_for_completion()\n                execution_result = tm_obj.verdict\n                break\n            else:\n                continue\n        if test_module_found and (execution_result == 1):\n            self.log.info(\n                f'test module \"{test_env_name}.{test_module_name}\" executed and verdict = {test_verdict[execution_result]}.')\n        elif test_module_found and (execution_result != 1):\n            self.log.info(\n                f'test module \"{test_env_name}.{test_module_name}\" executed and verdict = {test_verdict[execution_result]}.')\n        else:\n            self.log.info(f'test module \"{test_env_name}.{test_module_name}\" not found. not possible to execute.')\n        return execution_result\n\n    def stop_test_module(self, env_name: str, module_name: str):\n        \"\"\"stops execution of test module.\n\n        Args:\n            module_name (str): test module name. avoid duplicate test module names in CANoe configuration.\n        \"\"\"\n        test_modules = self.get_test_modules(test_env_name=env_name)\n        if test_modules:\n            if module_name in test_modules.keys():\n                test_modules[module_name].stop()\n            else:\n                self.log.info(f'test module not found in \"{env_name}\" test environment.')\n        else:\n            self.log.info(f'test modules not available in \"{env_name}\" test environment.')\n\n    def execute_all_test_modules_in_test_env(self, env_name: str):\n        \"\"\"executes all test modules available in test environment.\n\n        Args:\n            env_name (str): test environment name. avoid duplicate test environment names in CANoe configuration.\n        \"\"\"\n        test_modules = self.get_test_modules(test_env_name=env_name)\n        if test_modules:\n            for tm_name in test_modules.keys():\n                self.execute_test_module(tm_name)\n        else:\n            self.log.info(f'test modules not available in \"{env_name}\" test environment.')\n\n    def stop_all_test_modules_in_test_env(self, env_name: str):\n        \"\"\"stops execution of all test modules available in test environment.\n\n        Args:\n            env_name (str): test environment name. avoid duplicate test environment names in CANoe configuration.\n        \"\"\"\n        test_modules = self.get_test_modules(test_env_name=env_name)\n        if test_modules:\n            for tm_name in test_modules.keys():\n                self.stop_test_module(env_name, tm_name)\n        else:\n            self.log.info(f'test modules not available in \"{env_name}\" test environment.')\n\n    def execute_all_test_environments(self):\n        \"\"\"executes all test environments available in test setup.\n        \"\"\"\n        test_environments = self.get_test_environments()\n        if len(test_environments) &gt; 0:\n            for test_env_name in test_environments.keys():\n                self.log.info(f'started executing test environment \"{test_env_name}\"...')\n                self.execute_all_test_modules_in_test_env(test_env_name)\n                self.log.info(f'completed executing test environment \"{test_env_name}\"')\n        else:\n            self.log.info(f'Zero test environments found in configuration.')\n\n    def stop_all_test_environments(self):\n        \"\"\"stops execution of all test environments available in test setup.\n        \"\"\"\n        test_environments = self.get_test_environments()\n        if len(test_environments) &gt; 0:\n            for test_env_name in test_environments.keys():\n                self.log.info(f'stopping test environment \"{test_env_name}\" execution')\n                self.stop_all_test_modules_in_test_env(test_env_name)\n                self.log.info(f'completed stopping test environment \"{test_env_name}\"')\n        else:\n            self.log.info(f'Zero test environments found in configuration.')\n\n    def get_environment_variable_value(self, env_var_name: str) -&gt; Union[int, float, str, tuple, None]:\n        r\"\"\"returns a environment variable value.\n\n        Args:\n            env_var_name (str): The name of the environment variable. Ex- \"float_var\"\n\n        Returns:\n            Environment Variable value.\n        \"\"\"\n        var_value = None\n        try:\n            variable = self.application.environment.get_variable(env_var_name)\n            var_value = variable.value if variable.type != 3 else tuple(variable.value)\n            self.log.info(f'environment variable({env_var_name}) value &lt;- {var_value}')\n        except Exception as e:\n            self.log.info(f'failed to get environment variable({env_var_name}) value. {e}')\n        return var_value\n\n    def set_environment_variable_value(self, env_var_name: str, value: Union[int, float, str, tuple]) -&gt; None:\n        r\"\"\"sets a value to environment variable.\n\n        Args:\n            env_var_name (str): The name of the environment variable. Ex- \"speed\".\n            value (Union[int, float, str, tuple]): variable value. supported CAPL environment variable data types integer, double, string and data.\n        \"\"\"\n        try:\n            variable = self.application.environment.get_variable(env_var_name)\n            if variable.type == 0:\n                converted_value = int(value)\n            elif variable.type == 1:\n                converted_value = float(value)            \n            elif variable.type == 2:\n                converted_value = str(value)\n            else:\n                converted_value = tuple(value)\n            variable.value = converted_value\n            self.log.info(f'environment variable({env_var_name}) value set to -&gt; {converted_value}')\n        except Exception as e:\n            self.log.info(f'failed to set system variable({env_var_name}) value. {e}')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.__init__","title":"<code>__init__(py_canoe_log_dir='', user_capl_functions=tuple())</code>","text":"<p>Parameters:</p> Name Type Description Default <code>py_canoe_log_dir</code> <code>str</code> <p>directory to store py_canoe log. example 'D:.py_canoe'</p> <code>''</code> <code>user_capl_functions</code> <code>tuple</code> <p>user defined CAPL functions to access. on measurement init these functions will be initialized.</p> <code>tuple()</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def __init__(self, py_canoe_log_dir='', user_capl_functions=tuple()):\n    \"\"\"\n    Args:\n        py_canoe_log_dir (str): directory to store py_canoe log. example 'D:\\\\.py_canoe'\n        user_capl_functions (tuple): user defined CAPL functions to access. on measurement init these functions will be initialized.\n    \"\"\"\n    pcl = PyCanoeLogger(py_canoe_log_dir)\n    self.log = pcl.log\n    self.application: Application\n    self.__diag_devices = dict()\n    self.__test_environments = dict()\n    self.__test_modules = list()\n    self.__replay_blocks = dict()\n    self.user_capl_function_names = user_capl_functions\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.add_offline_source_log_file","title":"<code>add_offline_source_log_file(absolute_log_file_path)</code>","text":"<p>this method adds offline source log file.</p> <p>Parameters:</p> Name Type Description Default <code>absolute_log_file_path</code> <code>str</code> <p>absolute path of offline source log file.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns True if log file added or already available. False if log file not available.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def add_offline_source_log_file(self, absolute_log_file_path: str) -&gt; bool:\n    r\"\"\"this method adds offline source log file.\n\n    Args:\n        absolute_log_file_path (str): absolute path of offline source log file.\n\n    Returns:\n        bool: returns True if log file added or already available. False if log file not available.\n    \"\"\"\n    if os.path.isfile(absolute_log_file_path):\n        offline_sources = self.application.configuration.com_obj.OfflineSetup.Source.Sources\n        file_already_added = any([file == absolute_log_file_path for file in offline_sources])\n        if file_already_added:\n            self.log.info(f'offline logging file ({absolute_log_file_path}) already added.')\n        else:\n            offline_sources.Add(absolute_log_file_path)\n            self.log.info(f'added offline logging file ({absolute_log_file_path})')\n        return True\n    else:\n        self.log.info(f'invalid logging file ({absolute_log_file_path}). Failed to add.')\n        return False\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.break_measurement_in_offline_mode","title":"<code>break_measurement_in_offline_mode()</code>","text":"<p>Interrupts the playback in Offline mode.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def break_measurement_in_offline_mode(self) -&gt; None:\n    r\"\"\"Interrupts the playback in Offline mode.\n    \"\"\"\n    self.application.measurement.break_offline_mode()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.call_capl_function","title":"<code>call_capl_function(name, *arguments)</code>","text":"<p>Calls a CAPL function. Please note that the number of parameters must agree with that of the CAPL function. not possible to read return value of CAPL function at the moment. only execution status is returned.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the CAPL function. Please make sure this name is already passed as argument during CANoe instance creation. see example for more info.</p> required <code>arguments</code> <code>tuple</code> <p>Function parameters p1\u2026p10 (optional).</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>CAPL function execution status. True-success, False-failed.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def call_capl_function(self, name: str, *arguments) -&gt; bool:\n    r\"\"\"Calls a CAPL function.\n    Please note that the number of parameters must agree with that of the CAPL function.\n    not possible to read return value of CAPL function at the moment. only execution status is returned.\n\n    Args:\n        name (str): The name of the CAPL function. Please make sure this name is already passed as argument during CANoe instance creation. see example for more info.\n        arguments (tuple): Function parameters p1\u2026p10 (optional).\n\n    Returns:\n        bool: CAPL function execution status. True-success, False-failed.\n    \"\"\"\n    capl_obj = self.application.capl\n    exec_sts = capl_obj.call_capl_function(self.application.measurement.user_capl_function_obj_dict[name], *arguments)\n    self.log.info(f'triggered capl function({name}). execution status = {exec_sts}.')\n    return exec_sts\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_j1939_signal_online","title":"<code>check_j1939_signal_online(bus, channel, message, signal, source_addr, dest_addr)</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>TRUE: if the measurement is running and the signal has been received. FALSE: if not.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_j1939_signal_online(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; bool:\n    \"\"\"Checks whether the measurement is running and the signal has been received.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n\n    Returns:\n        bool: TRUE: if the measurement is running and the signal has been received. FALSE: if not.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n    signal_online_status = bus_obj.signal_is_online(sig_obj)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) online status = {signal_online_status}.')\n    return signal_online_status\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_j1939_signal_state","title":"<code>check_j1939_signal_state(bus, channel, message, signal, source_addr, dest_addr)</code>","text":"<p>Returns the state of the signal.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>State of the signal. possible values are:     0: The default value of the signal is returned.     1: The measurement is not running; the value set by the application is returned.     3: The signal has been received in the current measurement; the current value is returned.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_j1939_signal_state(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; int:\n    \"\"\"Returns the state of the signal.\n\n    Returns:\n        int: State of the signal.\n            possible values are:\n                0: The default value of the signal is returned.\n                1: The measurement is not running; the value set by the application is returned.\n                3: The signal has been received in the current measurement; the current value is returned.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n    signal_state = bus_obj.signal_state(sig_obj)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) state = {signal_state}.')\n    return signal_state\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_signal_online","title":"<code>check_signal_online(bus, channel, message, signal)</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>TRUE if the measurement is running and the signal has been received. FALSE if not.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_signal_online(self, bus: str, channel: int, message: str, signal: str) -&gt; bool:\n    r\"\"\"Checks whether the measurement is running and the signal has been received.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        TRUE if the measurement is running and the signal has been received. FALSE if not.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_signal(channel, message, signal)\n    sig_online_status = bus_obj.signal_is_online(sig_obj)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) online status = {sig_online_status}.')\n    return sig_online_status\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_signal_state","title":"<code>check_signal_state(bus, channel, message, signal)</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Type Description <code>int</code> <p>State of the signal. 0- The default value of the signal is returned.  1- The measurement is not running; the value set by the application is returned.  2- The measurement is not running; the value of the last measurement is returned.  3- The signal has been received in the current measurement; the current value is returned.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_signal_state(self, bus: str, channel: int, message: str, signal: str) -&gt; int:\n    r\"\"\"Checks whether the measurement is running and the signal has been received.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        State of the signal.\n            0- The default value of the signal is returned. \n            1- The measurement is not running; the value set by the application is returned. \n            2- The measurement is not running; the value of the last measurement is returned. \n            3- The signal has been received in the current measurement; the current value is returned.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_signal(channel, message, signal)\n    sig_state = bus_obj.signal_state(sig_obj)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) state = {sig_state}.')\n    return sig_state\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.clear_write_window_content","title":"<code>clear_write_window_content()</code>","text":"<p>Clears the contents of the Write Window.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def clear_write_window_content(self) -&gt; None:\n    r\"\"\"Clears the contents of the Write Window.\n    \"\"\"\n    self.application.ui.write.clear()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.compile_all_capl_nodes","title":"<code>compile_all_capl_nodes()</code>","text":"<p>compiles all CAPL, XML and .NET nodes.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def compile_all_capl_nodes(self) -&gt; dict:\n    r\"\"\"compiles all CAPL, XML and .NET nodes.\n    \"\"\"\n    capl_obj = self.application.capl\n    capl_obj.compile()\n    wait(1)\n    compile_result = capl_obj.compile_result()\n    self.log.info(f'compiled all CAPL nodes successfully. result={compile_result[\"result\"]}')\n    return compile_result\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.control_replay_block","title":"<code>control_replay_block(block_name, start_stop)</code>","text":"<p>Method for setting CANoe replay block file.</p> <p>Parameters:</p> Name Type Description Default <code>block_name</code> <code>str</code> <p>CANoe replay block name</p> required <code>start_stop</code> <code>bool</code> <p>True to start replay block. False to Stop.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def control_replay_block(self, block_name: str, start_stop: bool) -&gt; None:\n    r\"\"\"Method for setting CANoe replay block file.\n\n    Args:\n        block_name (str): CANoe replay block name\n        start_stop (bool): True to start replay block. False to Stop.\n    \"\"\"\n    replay_blocks = self.__replay_blocks\n    if block_name in replay_blocks.keys():\n        replay_block = replay_blocks[block_name]\n        if start_stop:\n            replay_block.start()\n        else:\n            replay_block.stop()\n        self.log.info(f'Replay block \"{block_name}\" {\"Started\" if start_stop else \"Stopped\"}.')\n    else:\n        self.log.warning(f'Replay block \"{block_name}\" not available.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.control_tester_present","title":"<code>control_tester_present(diag_ecu_qualifier_name, value)</code>","text":"<p>Starts/Stops sending autonomous/cyclical Tester Present requests to the ECU.</p> <p>Parameters:</p> Name Type Description Default <code>diag_ecu_qualifier_name</code> <code>str</code> <p>Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".</p> required <code>value</code> <code>bool</code> <p>True - activate tester present. False - deactivate tester present.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def control_tester_present(self, diag_ecu_qualifier_name: str, value: bool) -&gt; None:\n    \"\"\"Starts/Stops sending autonomous/cyclical Tester Present requests to the ECU.\n\n    Args:\n        diag_ecu_qualifier_name (str): Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".\n        value (bool): True - activate tester present. False - deactivate tester present.\n    \"\"\"\n    if diag_ecu_qualifier_name in self.__diag_devices.keys():\n        diag_device = self.__diag_devices[diag_ecu_qualifier_name]\n        if diag_device.tester_present_status != value:\n            if value:\n                diag_device.start_tester_present()\n                self.log.info(f'{diag_ecu_qualifier_name}: started tester present')\n            else:\n                diag_device.stop_tester_present()\n                self.log.info(f'{diag_ecu_qualifier_name}: stopped tester present')\n            wait(.1)\n        else:\n            self.log.info(f'{diag_ecu_qualifier_name}: tester present already set to {value}')\n    else:\n        self.log.info(f'diag ECU qualifier \"{diag_ecu_qualifier_name}\" not available in configuration.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.copy_write_window_content","title":"<code>copy_write_window_content()</code>","text":"<p>Copies the contents of the Write Window to the clipboard.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def copy_write_window_content(self) -&gt; None:\n    r\"\"\"Copies the contents of the Write Window to the clipboard.\n    \"\"\"\n    self.application.ui.write.copy()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.define_system_variable","title":"<code>define_system_variable(sys_var_name, value)</code>","text":"<p>define_system_variable Create a system variable with an initial value Args:     sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"     value (Union[int, float, str]): variable value. Default value 0.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Variable object.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def define_system_variable(self, sys_var_name: str, value: Union[int, float, str]) -&gt; object:\n    r\"\"\"define_system_variable Create a system variable with an initial value\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n        value (Union[int, float, str]): variable value. Default value 0.\n\n    Returns:\n        object: The new Variable object.\n    \"\"\"\n    namespace_name = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    new_var_com_obj = None\n    try:\n        self.application.system.namespaces.add(namespace_name)\n        namespaces = self.application.system.namespaces.fetch_namespaces()\n        namespace = namespaces[namespace_name]\n        new_var_com_obj = namespace.variables.add(variable_name, value)\n        self.log.info(f'system variable({sys_var_name}) created and value set to {value}.')\n    except Exception as e:\n        self.log.info(f'failed to create system variable({sys_var_name}). {e}')\n    return new_var_com_obj\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.disable_write_window_output_file","title":"<code>disable_write_window_output_file(tab_index=None)</code>","text":"<p>Disables logging of all outputs of the Write Window.</p> <p>Parameters:</p> Name Type Description Default <code>tab_index</code> <code>int</code> <p>The index of the page, for which logging of the output is to be activated. Defaults to None.</p> <code>None</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def disable_write_window_output_file(self, tab_index=None) -&gt; None:\n    r\"\"\"Disables logging of all outputs of the Write Window.\n\n    Args:\n        tab_index (int, optional): The index of the page, for which logging of the output is to be activated. Defaults to None.\n    \"\"\"\n    self.application.ui.write.disable_output_file(tab_index)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.enable_write_window_output_file","title":"<code>enable_write_window_output_file(output_file, tab_index=None)</code>","text":"<p>Enables logging of all outputs of the Write Window in the output file.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str</code> <p>The complete path of the output file.</p> required <code>tab_index</code> <code>int</code> <p>The index of the page, for which logging of the output is to be activated. Defaults to None.</p> <code>None</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def enable_write_window_output_file(self, output_file: str, tab_index=None) -&gt; None:\n    r\"\"\"Enables logging of all outputs of the Write Window in the output file.\n\n    Args:\n        output_file (str): The complete path of the output file.\n        tab_index (int, optional): The index of the page, for which logging of the output is to be activated. Defaults to None.\n    \"\"\"\n    self.application.ui.write.enable_output_file(output_file, tab_index)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.execute_all_test_environments","title":"<code>execute_all_test_environments()</code>","text":"<p>executes all test environments available in test setup.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def execute_all_test_environments(self):\n    \"\"\"executes all test environments available in test setup.\n    \"\"\"\n    test_environments = self.get_test_environments()\n    if len(test_environments) &gt; 0:\n        for test_env_name in test_environments.keys():\n            self.log.info(f'started executing test environment \"{test_env_name}\"...')\n            self.execute_all_test_modules_in_test_env(test_env_name)\n            self.log.info(f'completed executing test environment \"{test_env_name}\"')\n    else:\n        self.log.info(f'Zero test environments found in configuration.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.execute_all_test_modules_in_test_env","title":"<code>execute_all_test_modules_in_test_env(env_name)</code>","text":"<p>executes all test modules available in test environment.</p> <p>Parameters:</p> Name Type Description Default <code>env_name</code> <code>str</code> <p>test environment name. avoid duplicate test environment names in CANoe configuration.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def execute_all_test_modules_in_test_env(self, env_name: str):\n    \"\"\"executes all test modules available in test environment.\n\n    Args:\n        env_name (str): test environment name. avoid duplicate test environment names in CANoe configuration.\n    \"\"\"\n    test_modules = self.get_test_modules(test_env_name=env_name)\n    if test_modules:\n        for tm_name in test_modules.keys():\n            self.execute_test_module(tm_name)\n    else:\n        self.log.info(f'test modules not available in \"{env_name}\" test environment.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.execute_test_module","title":"<code>execute_test_module(test_module_name)</code>","text":"<p>use this method to execute test module.</p> <p>Parameters:</p> Name Type Description Default <code>test_module_name</code> <code>str</code> <p>test module name. avoid duplicate test module names in CANoe configuration.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>test module execution verdict. 0 ='VerdictNotAvailable', 1 = 'VerdictPassed', 2 = 'VerdictFailed',</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def execute_test_module(self, test_module_name: str) -&gt; int:\n    \"\"\"use this method to execute test module.\n\n    Args:\n        test_module_name (str): test module name. avoid duplicate test module names in CANoe configuration.\n\n    Returns:\n        int: test module execution verdict. 0 ='VerdictNotAvailable', 1 = 'VerdictPassed', 2 = 'VerdictFailed',\n    \"\"\"\n    test_verdict = {0: 'NotAvailable',\n                    1: 'Passed',\n                    2: 'Failed',\n                    3: 'None (not available for test modules)',\n                    4: 'Inconclusive (not available for test modules)',\n                    5: 'ErrorInTestSystem (not available for test modules)', }\n    execution_result = 0\n    test_module_found = False\n    test_env_name = ''\n    for tm in self.__test_modules:\n        if tm['name'] == test_module_name:\n            test_module_found = True\n            tm_obj = tm['object']\n            test_env_name = tm['environment']\n            self.log.info(f'test module \"{test_module_name}\" found in \"{test_env_name}\"')\n            tm_obj.start()\n            tm_obj.wait_for_completion()\n            execution_result = tm_obj.verdict\n            break\n        else:\n            continue\n    if test_module_found and (execution_result == 1):\n        self.log.info(\n            f'test module \"{test_env_name}.{test_module_name}\" executed and verdict = {test_verdict[execution_result]}.')\n    elif test_module_found and (execution_result != 1):\n        self.log.info(\n            f'test module \"{test_env_name}.{test_module_name}\" executed and verdict = {test_verdict[execution_result]}.')\n    else:\n        self.log.info(f'test module \"{test_env_name}.{test_module_name}\" not found. not possible to execute.')\n    return execution_result\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_bus_databases_info","title":"<code>get_bus_databases_info(bus)</code>","text":"<p>returns bus database info(path, channel, full_name).</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>bus database info {'path': 'value', 'channel': 'value', 'full_name': 'value'}</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_bus_databases_info(self, bus: str) -&gt; dict:\n    \"\"\"returns bus database info(path, channel, full_name).\n\n    Args:\n        bus (str): bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n\n    Returns:\n        bus database info {'path': 'value', 'channel': 'value', 'full_name': 'value'}\n    \"\"\"\n    dbcs_info = dict()\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    db_objects = bus_obj.database_objects()\n    for db_object in db_objects.values():\n        dbcs_info[db_object.Name] = {'path': db_object.Path, 'channel': db_object.Channel, 'full_name': db_object.FullName}\n    self.log.info(f'{bus} bus databases info -&gt; {dbcs_info}.')\n    return dbcs_info\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_bus_nodes_info","title":"<code>get_bus_nodes_info(bus)</code>","text":"<p>returns bus nodes info(path, full_name, active).</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>bus nodes info {'path': 'value', 'full_name': 'value', 'active': 'value'}</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_bus_nodes_info(self, bus: str) -&gt; dict:\n    \"\"\"returns bus nodes info(path, full_name, active).\n\n    Args:\n        bus (str): bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n\n    Returns:\n        bus nodes info {'path': 'value', 'full_name': 'value', 'active': 'value'}\n    \"\"\"\n    nodes_info = dict()\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    node_objects = bus_obj.node_objects()\n    for n_object in node_objects.values():\n        nodes_info[n_object.Name] = {'path': n_object.Path, 'full_name': n_object.FullName, 'active': n_object.Active}\n    self.log.info(f'{bus} bus nodes info -&gt; {nodes_info}.')\n    return nodes_info\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_can_bus_statistics","title":"<code>get_can_bus_statistics(channel)</code>","text":"<p>Returns CAN Bus Statistics.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel of the statistic that is to be returned.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>CAN bus statistics.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_can_bus_statistics(self, channel: int) -&gt; dict:\n    r\"\"\"Returns CAN Bus Statistics.\n\n    Args:\n        channel (int): The channel of the statistic that is to be returned.\n\n    Returns:\n        CAN bus statistics.\n    \"\"\"\n    conf_obj = self.application.configuration\n    bus_types = {'CAN': 1, 'J1939': 2, 'TTP': 4, 'LIN': 5, 'MOST': 6, 'Kline': 14}\n    bus_statistics_obj = conf_obj.com_obj.OnlineSetup.BusStatistics.BusStatistic(bus_types['CAN'], channel)\n    statistics_info = {\n        # The bus load\n        'bus_load': bus_statistics_obj.BusLoad,\n        # The controller status\n        'chip_state': bus_statistics_obj.ChipState,\n        # The number of Error Frames per second\n        'error': bus_statistics_obj.Error,\n        # The total number of Error Frames\n        'error_total': bus_statistics_obj.ErrorTotal,\n        # The number of messages with extended identifier per second\n        'extended': bus_statistics_obj.Extended,\n        # The total number of messages with extended identifier\n        'extended_total': bus_statistics_obj.ExtendedTotal,\n        # The number of remote messages with extended identifier per second\n        'extended_remote': bus_statistics_obj.ExtendedRemote,\n        # The total number of remote messages with extended identifier\n        'extended_remote_total': bus_statistics_obj.ExtendedRemoteTotal,\n        # The number of overload frames per second\n        'overload': bus_statistics_obj.Overload,\n        # The total number of overload frames\n        'overload_total': bus_statistics_obj.OverloadTotal,\n        # The maximum bus load in 0.01 %\n        'peak_load': bus_statistics_obj.PeakLoad,\n        # Returns the current number of the Rx error counter\n        'rx_error_count': bus_statistics_obj.RxErrorCount,\n        # The number of messages with standard identifier per second\n        'standard': bus_statistics_obj.Standard,\n        # The total number of remote messages with standard identifier\n        'standard_total': bus_statistics_obj.StandardTotal,\n        # The number of remote messages with standard identifier per second\n        'standard_remote': bus_statistics_obj.StandardRemote,\n        # The total number of remote messages with standard identifier\n        'standard_remote_total': bus_statistics_obj.StandardRemoteTotal,\n        # The current number of the Tx error counter\n        'tx_error_count': bus_statistics_obj.TxErrorCount,\n    }\n    self.log.info(f'CAN Bus Statistics: {statistics_info}.')\n    return statistics_info\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_canoe_version_info","title":"<code>get_canoe_version_info()</code>","text":"<p>The Version class represents the version of the CANoe application.</p> <p>Returns:</p> Type Description <code>dict</code> <p>\"full_name\" - The complete CANoe version.</p> <code>dict</code> <p>\"name\" - The CANoe version.</p> <code>dict</code> <p>\"build\" - The build number of the CANoe application.</p> <code>dict</code> <p>\"major\" - The major version number of the CANoe application.</p> <code>dict</code> <p>\"minor\" - The minor version number of the CANoe application.</p> <code>dict</code> <p>\"patch\" - The patch number of the CANoe application.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_canoe_version_info(self) -&gt; dict:\n    r\"\"\"The Version class represents the version of the CANoe application.\n\n    Returns:\n        \"full_name\" - The complete CANoe version.\n        \"name\" - The CANoe version.\n        \"build\" - The build number of the CANoe application.\n        \"major\" - The major version number of the CANoe application.\n        \"minor\" - The minor version number of the CANoe application.\n        \"patch\" - The patch number of the CANoe application.\n    \"\"\"\n    ver_obj = self.application.version\n    version_info = {'full_name': ver_obj.full_name,\n                    'name': ver_obj.name,\n                    'build': ver_obj.build,\n                    'major': ver_obj.major,\n                    'minor': ver_obj.minor,\n                    'patch': ver_obj.patch}\n    self.log.info('&gt; CANoe Application.Version &lt;'.center(100, '='))\n    for k, v in version_info.items():\n        self.log.info(f'{k:&lt;10}: {v}')\n    self.log.info(''.center(100, '='))\n    return version_info\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_environment_variable_value","title":"<code>get_environment_variable_value(env_var_name)</code>","text":"<p>returns a environment variable value.</p> <p>Parameters:</p> Name Type Description Default <code>env_var_name</code> <code>str</code> <p>The name of the environment variable. Ex- \"float_var\"</p> required <p>Returns:</p> Type Description <code>Union[int, float, str, tuple, None]</code> <p>Environment Variable value.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_environment_variable_value(self, env_var_name: str) -&gt; Union[int, float, str, tuple, None]:\n    r\"\"\"returns a environment variable value.\n\n    Args:\n        env_var_name (str): The name of the environment variable. Ex- \"float_var\"\n\n    Returns:\n        Environment Variable value.\n    \"\"\"\n    var_value = None\n    try:\n        variable = self.application.environment.get_variable(env_var_name)\n        var_value = variable.value if variable.type != 3 else tuple(variable.value)\n        self.log.info(f'environment variable({env_var_name}) value &lt;- {var_value}')\n    except Exception as e:\n        self.log.info(f'failed to get environment variable({env_var_name}) value. {e}')\n    return var_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_j1939_signal_full_name","title":"<code>get_j1939_signal_full_name(bus, channel, message, signal, source_addr, dest_addr)</code>","text":"<p>Determines the fully qualified name of a signal.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully qualified name of a signal. The following format will be used for signals: :::: Source code in <code>src\\py_canoe.py</code> <pre><code>def get_j1939_signal_full_name(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; str:\n    \"\"\"Determines the fully qualified name of a signal.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n\n    Returns:\n        str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n    signal_fullname = bus_obj.signal_full_name(sig_obj)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) full name = {signal_fullname}.')\n    return signal_fullname\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_j1939_signal_value","title":"<code>get_j1939_signal_value(bus, channel, message, signal, source_addr, dest_addr, raw_value=False)</code>","text":"<p>get_j1939_signal Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[float, int]</code> <p>signal value.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int, raw_value=False) -&gt; Union[float, int]:\n    r\"\"\"get_j1939_signal Returns a Signal object.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Returns:\n        signal value.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n    signal_value = bus_obj.signal_get_raw_value(sig_obj) if raw_value else bus_obj.signal_get_value(sig_obj)\n    self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n    return signal_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_measurement_index","title":"<code>get_measurement_index()</code>","text":"<p>gets the measurement index for the next measurement.</p> <p>Returns:</p> Type Description <code>int</code> <p>Measurement Index.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_measurement_index(self) -&gt; int:\n    r\"\"\"gets the measurement index for the next measurement.\n\n    Returns:\n        Measurement Index.\n    \"\"\"\n    self.log.info(f'measurement_index value = {self.application.measurement.measurement_index}')\n    return self.application.measurement.measurement_index\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_measurement_running_status","title":"<code>get_measurement_running_status()</code>","text":"<p>Returns the running state of the measurement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if The measurement is running.</p> <code>bool</code> <p>False if The measurement is not running.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_measurement_running_status(self) -&gt; bool:\n    r\"\"\"Returns the running state of the measurement.\n\n    Returns:\n        True if The measurement is running.\n        False if The measurement is not running.\n    \"\"\"\n    self.log.info(f'CANoe Measurement Running Status = {self.application.measurement.running}')\n    return self.application.measurement.running\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_signal_full_name","title":"<code>get_signal_full_name(bus, channel, message, signal)</code>","text":"<p>Determines the fully qualified name of a signal.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully qualified name of a signal. The following format will be used for signals: :::: Source code in <code>src\\py_canoe.py</code> <pre><code>def get_signal_full_name(self, bus: str, channel: int, message: str, signal: str) -&gt; str:\n    \"\"\"Determines the fully qualified name of a signal.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_signal(channel, message, signal)\n    signal_fullname = bus_obj.signal_full_name(sig_obj)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) full name = {signal_fullname}.')\n    return signal_fullname\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_signal_value","title":"<code>get_signal_value(bus, channel, message, signal, raw_value=False)</code>","text":"<p>get_signal_value Returns a Signal value.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[float, int]</code> <p>signal value.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_signal_value(self, bus: str, channel: int, message: str, signal: str, raw_value=False) -&gt; Union[float, int]:\n    r\"\"\"get_signal_value Returns a Signal value.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Returns:\n        signal value.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_signal(channel, message, signal)\n    signal_value = bus_obj.signal_get_raw_value(sig_obj) if raw_value else bus_obj.signal_get_value(sig_obj)\n    self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n    return signal_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_system_variable_value","title":"<code>get_system_variable_value(sys_var_name)</code>","text":"<p>get_system_variable_value Returns a system variable value.</p> <p>Parameters:</p> Name Type Description Default <code>sys_var_name</code> <code>str</code> <p>The name of the system variable. Ex- \"sys_var_demo::speed\"</p> required <p>Returns:</p> Type Description <code>Union[int, float, str, tuple, None]</code> <p>System Variable value.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_system_variable_value(self, sys_var_name: str) -&gt; Union[int, float, str, tuple, None]:\n    r\"\"\"get_system_variable_value Returns a system variable value.\n\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n\n    Returns:\n        System Variable value.\n    \"\"\"\n    namespace = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    return_value = None\n    try:\n        namespace_com_object = self.application.system.com_obj.Namespaces(namespace)\n        variable_com_object = namespace_com_object.Variables(variable_name)\n        return_value = variable_com_object.Value\n        self.log.info(f'system variable({sys_var_name}) value &lt;- {return_value}.')\n    except Exception as e:\n        self.log.info(f'failed to get system variable({sys_var_name}) value. {e}')\n    return return_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_test_environments","title":"<code>get_test_environments()</code>","text":"<p>returns dictionary of test environment names and class.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_test_environments(self) -&gt; dict:\n    \"\"\"returns dictionary of test environment names and class.\n    \"\"\"\n    return self.__test_environments\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_test_modules","title":"<code>get_test_modules(test_env_name)</code>","text":"<p>returns dictionary of test module names and class.</p> <p>Parameters:</p> Name Type Description Default <code>test_env_name</code> <code>str</code> <p>test environment name. avoid duplicate test environment names in CANoe configuration.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def get_test_modules(self, test_env_name: str) -&gt; dict:\n    \"\"\"returns dictionary of test module names and class.\n\n    Args:\n        test_env_name (str): test environment name. avoid duplicate test environment names in CANoe configuration.\n    \"\"\"\n    test_environments = self.get_test_environments()\n    if len(test_environments) &gt; 0:\n        if test_env_name in test_environments.keys():\n            return test_environments[test_env_name].get_all_test_modules()\n        else:\n            self.log.info(f'\"{test_env_name}\" not found in configuration.')\n            return {}\n    else:\n        self.log.info(f'Zero test environments found in configuration. Not possible to fetch test modules.')\n        return {}\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.new","title":"<code>new(auto_save=False, prompt_user=False)</code>","text":"<p>Creates a new configuration.</p> <p>Parameters:</p> Name Type Description Default <code>auto_save</code> <code>bool</code> <p>A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.</p> <code>False</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations. Defaults to False.</p> <code>False</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def new(self, auto_save=False, prompt_user=False) -&gt; None:\n    \"\"\"Creates a new configuration.\n\n    Args:\n        auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n    \"\"\"\n    self.application.new(auto_save, prompt_user)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.open","title":"<code>open(canoe_cfg, visible=True, auto_save=False, prompt_user=False)</code>","text":"<p>Loads CANoe configuration.</p> <p>Parameters:</p> Name Type Description Default <code>canoe_cfg</code> <code>str</code> <p>The complete path for the CANoe configuration.</p> required <code>visible</code> <code>bool</code> <p>True if you want to see CANoe UI. Defaults to True.</p> <code>True</code> <code>auto_save</code> <code>bool</code> <p>A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.</p> <code>False</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations. Defaults to False.</p> <code>False</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def open(self, canoe_cfg: str, visible=True, auto_save=False, prompt_user=False) -&gt; None:\n    r\"\"\"Loads CANoe configuration.\n\n    Args:\n        canoe_cfg (str): The complete path for the CANoe configuration.\n        visible (bool): True if you want to see CANoe UI. Defaults to True.\n        auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n    \"\"\"\n    pythoncom.CoInitialize()\n    self.application = Application(self.user_capl_function_names)\n    self.application.visible = visible\n    self.application.open(path=canoe_cfg, auto_save=auto_save, prompt_user=prompt_user)\n    self.__diag_devices = self.application.networks.fetch_all_diag_devices()\n    self.__test_environments = self.application.configuration.get_all_test_setup_environments()\n    self.__test_modules = self.application.configuration.get_all_test_modules_in_test_environments()\n    self.__replay_blocks = self.application.configuration.simulation_setup.replay_collection.fetch_replay_blocks()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.quit","title":"<code>quit()</code>","text":"<p>Quits CANoe without saving changes in the configuration.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def quit(self):\n    r\"\"\"Quits CANoe without saving changes in the configuration.\n    \"\"\"\n    self.application.quit()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.read_text_from_write_window","title":"<code>read_text_from_write_window()</code>","text":"<p>read the text contents from Write Window.</p> <p>Returns:</p> Type Description <code>str</code> <p>The text content.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def read_text_from_write_window(self) -&gt; str:\n    r\"\"\"read the text contents from Write Window.\n\n    Returns:\n        The text content.\n    \"\"\"\n    return self.application.ui.write.text\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.reset_measurement","title":"<code>reset_measurement()</code>","text":"<p>reset the measurement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Measurement running status(True/False).</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def reset_measurement(self) -&gt; bool:\n    r\"\"\"reset the measurement.\n\n    Returns:\n        Measurement running status(True/False).\n    \"\"\"\n    if self.application.measurement.running:\n        self.application.measurement.stop()\n    self.application.measurement.start()\n    self.log.info(f'Resetted measurement.')\n    return self.application.measurement.running\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.reset_measurement_in_offline_mode","title":"<code>reset_measurement_in_offline_mode()</code>","text":"<p>Resets the measurement in Offline mode.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def reset_measurement_in_offline_mode(self) -&gt; None:\n    r\"\"\"Resets the measurement in Offline mode.\n    \"\"\"\n    self.application.measurement.reset_offline_mode()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.save_configuration","title":"<code>save_configuration()</code>","text":"<p>Saves the configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration saved. else False.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def save_configuration(self) -&gt; bool:\n    r\"\"\"Saves the configuration.\n\n    Returns:\n        True if configuration saved. else False.\n    \"\"\"\n    return self.application.configuration.save()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.save_configuration_as","title":"<code>save_configuration_as(path, major, minor, create_dir=True)</code>","text":"<p>Saves the configuration as a different CANoe version.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The complete file name.</p> required <code>major</code> <code>int</code> <p>The major version number of the target version.</p> required <code>minor</code> <code>int</code> <p>The minor version number of the target version.</p> required <code>create_dir</code> <code>bool</code> <p>create directory if not available. default value True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration saved. else False.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def save_configuration_as(self, path: str, major: int, minor: int, create_dir=True) -&gt; bool:\n    r\"\"\"Saves the configuration as a different CANoe version.\n\n    Args:\n        path (str): The complete file name.\n        major (int): The major version number of the target version.\n        minor (int): The minor version number of the target version.\n        create_dir (bool): create directory if not available. default value True.\n\n    Returns:\n        True if configuration saved. else False.\n    \"\"\"\n    config_path = '\\\\'.join(path.split('\\\\')[:-1])\n    if not os.path.exists(config_path) and create_dir:\n        os.makedirs(config_path, exist_ok=True)\n    if os.path.exists(config_path):\n        self.application.configuration.save_as(path, major, minor, False)\n        return self.application.configuration.saved\n    else:\n        self.log.info(f'tried creating {path}. but {config_path} directory not found.')\n        return False\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.send_diag_request","title":"<code>send_diag_request(diag_ecu_qualifier_name, request, request_in_bytes=True, return_sender_name=False)</code>","text":"<p>The send_diag_request method represents the query of a diagnostic tester (client) to an ECU (server) in CANoe.</p> <p>Parameters:</p> Name Type Description Default <code>diag_ecu_qualifier_name</code> <code>str</code> <p>Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".</p> required <code>request</code> <code>str</code> <p>Diagnostic request in bytes or diagnostic request qualifier name.</p> required <code>request_in_bytes</code> <code>bool</code> <p>True if Diagnostic request is bytes. False if you are using Qualifier name. Default is True.</p> <code>True</code> <code>return_sender_name</code> <code>bool</code> <p>True if you user want response along with response sender name in dictionary. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, dict]</code> <p>diagnostic response stream. Ex- \"50 01 00 00 00 00\" or {'Door': \"50 01 00 00 00 00\"}</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def send_diag_request(self, diag_ecu_qualifier_name: str, request: str, request_in_bytes=True, return_sender_name=False) -&gt; Union[str, dict]:\n    r\"\"\"The send_diag_request method represents the query of a diagnostic tester (client) to an ECU (server) in CANoe.\n\n    Args:\n        diag_ecu_qualifier_name (str): Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".\n        request (str): Diagnostic request in bytes or diagnostic request qualifier name.\n        request_in_bytes (bool): True if Diagnostic request is bytes. False if you are using Qualifier name. Default is True.\n        return_sender_name (bool): True if you user want response along with response sender name in dictionary. Default is False.\n\n    Returns:\n        diagnostic response stream. Ex- \"50 01 00 00 00 00\" or {'Door': \"50 01 00 00 00 00\"}\n    \"\"\"\n    diag_response_data = \"\"\n    diag_response_including_sender_name = {}\n    try:\n        if diag_ecu_qualifier_name in self.__diag_devices.keys():\n            self.log.info(f'{diag_ecu_qualifier_name}: Diagnostic Request --&gt; {request}')\n            if request_in_bytes:\n                diag_req = self.__diag_devices[diag_ecu_qualifier_name].create_request_from_stream(request)\n            else:\n                diag_req = self.__diag_devices[diag_ecu_qualifier_name].create_request(request)\n            diag_req.send()\n            while diag_req.pending:\n                wait(0.1)\n            diag_req_responses = diag_req.responses\n            if len(diag_req_responses) == 0:\n                self.log.info(\"Diagnostic Response Not Received.\")\n            else:\n                for diag_res in diag_req_responses:\n                    diag_response_data = diag_res.stream\n                    diag_response_including_sender_name[diag_res.sender] = diag_response_data\n                    if diag_res.positive:\n                        self.log.info(f\"{diag_res.sender}: Diagnostic Response +ve &lt;-- {diag_response_data}\")\n                    else:\n                        self.log.info(f\"{diag_res.Sender}: Diagnostic Response -ve &lt;-- {diag_response_data}\")\n        else:\n            self.log.info(\n                f'Diagnostic ECU qualifier({diag_ecu_qualifier_name}) not available in loaded CANoe config.')\n    except Exception as e:\n        self.log.info(f'failed to send diagnostic request({request}). {e}')\n    return diag_response_including_sender_name if return_sender_name else diag_response_data\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_environment_variable_value","title":"<code>set_environment_variable_value(env_var_name, value)</code>","text":"<p>sets a value to environment variable.</p> <p>Parameters:</p> Name Type Description Default <code>env_var_name</code> <code>str</code> <p>The name of the environment variable. Ex- \"speed\".</p> required <code>value</code> <code>Union[int, float, str, tuple]</code> <p>variable value. supported CAPL environment variable data types integer, double, string and data.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def set_environment_variable_value(self, env_var_name: str, value: Union[int, float, str, tuple]) -&gt; None:\n    r\"\"\"sets a value to environment variable.\n\n    Args:\n        env_var_name (str): The name of the environment variable. Ex- \"speed\".\n        value (Union[int, float, str, tuple]): variable value. supported CAPL environment variable data types integer, double, string and data.\n    \"\"\"\n    try:\n        variable = self.application.environment.get_variable(env_var_name)\n        if variable.type == 0:\n            converted_value = int(value)\n        elif variable.type == 1:\n            converted_value = float(value)            \n        elif variable.type == 2:\n            converted_value = str(value)\n        else:\n            converted_value = tuple(value)\n        variable.value = converted_value\n        self.log.info(f'environment variable({env_var_name}) value set to -&gt; {converted_value}')\n    except Exception as e:\n        self.log.info(f'failed to set system variable({env_var_name}) value. {e}')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_j1939_signal_value","title":"<code>set_j1939_signal_value(bus, channel, message, signal, source_addr, dest_addr, value, raw_value=False)</code>","text":"<p>get_j1939_signal Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <code>value</code> <code>Union[float, int]</code> <p>signal value.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>signal value.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int, value: Union[float, int], raw_value=False) -&gt; None:\n    r\"\"\"get_j1939_signal Returns a Signal object.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n        value (Union[float, int]): signal value.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Returns:\n        signal value.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr)\n    if raw_value:\n        bus_obj.signal_set_raw_value(sig_obj, value)\n    else:\n        bus_obj.signal_set_value(sig_obj, value)\n    self.log.info(f'signal value set to {value}.')\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_measurement_index","title":"<code>set_measurement_index(index)</code>","text":"<p>sets the measurement index for the next measurement.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index value to set.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Measurement Index value.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_measurement_index(self, index: int) -&gt; int:\n    r\"\"\"sets the measurement index for the next measurement.\n\n    Args:\n        index (int): index value to set.\n\n    Returns:\n        Measurement Index value.\n    \"\"\"\n    self.application.measurement.measurement_index = index\n    return self.application.measurement.measurement_index\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_replay_block_file","title":"<code>set_replay_block_file(block_name, recording_file_path)</code>","text":"<p>Method for setting CANoe replay block file.</p> <p>Parameters:</p> Name Type Description Default <code>block_name</code> <code>str</code> <p>CANoe replay block name</p> required <code>recording_file_path</code> <code>str</code> <p>CANoe replay recording file including path.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def set_replay_block_file(self, block_name: str, recording_file_path: str) -&gt; None:\n    r\"\"\"Method for setting CANoe replay block file.\n\n    Args:\n        block_name: CANoe replay block name\n        recording_file_path: CANoe replay recording file including path.\n    \"\"\"\n    replay_blocks = self.__replay_blocks\n    if block_name in replay_blocks.keys():\n        replay_block = replay_blocks[block_name]\n        replay_block.path = recording_file_path\n        self.log.info(f'Replay block \"{block_name}\" updated with \"{recording_file_path}\" path.')\n    else:\n        self.log.warning(f'Replay block \"{block_name}\" not available.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_signal_value","title":"<code>set_signal_value(bus, channel, message, signal, value, raw_value=False)</code>","text":"<p>set_signal_value sets a value to Signal. Works only when messages are sent using CANoe IL.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>value</code> <code>Union[float, int]</code> <p>signal value.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_signal_value(self, bus: str, channel: int, message: str, signal: str, value: int, raw_value=False) -&gt; None:\n    r\"\"\"set_signal_value sets a value to Signal. Works only when messages are sent using CANoe IL.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        value (Union[float, int]): signal value.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n    \"\"\"\n    bus_obj = self.application.bus\n    if bus_obj.bus_type != bus:\n        bus_obj.reinit_bus(bus_type=bus)\n    sig_obj = bus_obj.get_signal(channel, message, signal)\n    if raw_value:\n        bus_obj.signal_set_raw_value(sig_obj, value)\n    else:\n        bus_obj.signal_set_value(sig_obj, value)\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_system_variable_array_values","title":"<code>set_system_variable_array_values(sys_var_name, value, index=0)</code>","text":"<p>set_system_variable_array_values sets array of values to system variable.</p> <p>Parameters:</p> Name Type Description Default <code>sys_var_name</code> <code>str</code> <p>The name of the system variable. Ex- \"sys_var_demo::speed\"</p> required <code>value</code> <code>tuple</code> <p>variable values. supported integer array or double array. please always give only one type.</p> required <code>index</code> <code>int</code> <p>value of index where values will start updating. Defaults to 0.</p> <code>0</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_system_variable_array_values(self, sys_var_name: str, value: tuple, index=0) -&gt; None:\n    r\"\"\"set_system_variable_array_values sets array of values to system variable.\n\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n        value (tuple): variable values. supported integer array or double array. please always give only one type.\n        index (int): value of index where values will start updating. Defaults to 0.\n    \"\"\"\n    namespace = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    try:\n        namespace_com_object = self.application.system.com_obj.Namespaces(namespace)\n        variable_com_object = namespace_com_object.Variables(variable_name)\n        existing_variable_value = list(variable_com_object.Value)\n        if (index + len(value)) &lt;= len(existing_variable_value):\n            final_value = existing_variable_value\n            if isinstance(existing_variable_value[0], float):\n                final_value[index: index + len(value)] = (float(v) for v in value)\n            else:\n                final_value[index: index + len(value)] = value\n            variable_com_object.Value = tuple(final_value)\n            wait(0.1)\n            self.log.info(f'system variable({sys_var_name}) value set to -&gt; {variable_com_object.Value}.')\n        else:\n            self.log.info(\n                f'failed to set system variable({sys_var_name}) value. check variable length and index value.')\n    except Exception as e:\n        self.log.info(f'failed to set system variable({sys_var_name}) value. {e}')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_system_variable_value","title":"<code>set_system_variable_value(sys_var_name, value)</code>","text":"<p>set_system_variable_value sets a value to system variable.</p> <p>Parameters:</p> Name Type Description Default <code>sys_var_name</code> <code>str</code> <p>The name of the system variable. Ex- \"sys_var_demo::speed\".</p> required <code>value</code> <code>Union[int, float, str]</code> <p>variable value. supported CAPL system variable data types integer, double, string and data.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def set_system_variable_value(self, sys_var_name: str, value: Union[int, float, str]) -&gt; None:\n    r\"\"\"set_system_variable_value sets a value to system variable.\n\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\".\n        value (Union[int, float, str]): variable value. supported CAPL system variable data types integer, double, string and data.\n    \"\"\"\n    namespace = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    try:\n        namespace_com_object = self.application.system.com_obj.Namespaces(namespace)\n        variable_com_object = namespace_com_object.Variables(variable_name)\n        if isinstance(variable_com_object.Value, int):\n            variable_com_object.Value = int(value)\n        elif isinstance(variable_com_object.Value, float):\n            variable_com_object.Value = float(value)\n        else:\n            variable_com_object.Value = value\n        self.log.info(f'system variable({sys_var_name}) value set to -&gt; {value}.')\n    except Exception as e:\n        self.log.info(f'failed to set system variable({sys_var_name}) value. {e}')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.start_measurement","title":"<code>start_measurement(timeout=60)</code>","text":"<p>Starts the measurement.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>measurement start/stop event timeout in seconds. Defaults to 60.</p> <code>60</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if measurement started. else False.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def start_measurement(self, timeout=60) -&gt; bool:\n    r\"\"\"Starts the measurement.\n\n    Args:\n        timeout (int, optional): measurement start/stop event timeout in seconds. Defaults to 60.\n\n    Returns:\n        True if measurement started. else False.\n    \"\"\"\n    self.application.measurement.meas_start_stop_timeout = timeout\n    return self.application.measurement.start()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.start_measurement_in_animation_mode","title":"<code>start_measurement_in_animation_mode(animation_delay=100)</code>","text":"<p>Starts the measurement in Animation mode.</p> <p>Parameters:</p> Name Type Description Default <code>animation_delay</code> <code>int</code> <p>The animation delay during the measurement in Offline Mode.</p> <code>100</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def start_measurement_in_animation_mode(self, animation_delay=100) -&gt; None:\n    r\"\"\"Starts the measurement in Animation mode.\n\n    Args:\n        animation_delay (int): The animation delay during the measurement in Offline Mode.\n    \"\"\"\n    self.application.measurement.animation_delay = animation_delay\n    self.application.measurement.animate()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.step_measurement_event_in_single_step","title":"<code>step_measurement_event_in_single_step()</code>","text":"<p>Processes a measurement event in single step.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def step_measurement_event_in_single_step(self) -&gt; None:\n    r\"\"\"Processes a measurement event in single step.\n    \"\"\"\n    self.application.measurement.step()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_all_test_environments","title":"<code>stop_all_test_environments()</code>","text":"<p>stops execution of all test environments available in test setup.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_all_test_environments(self):\n    \"\"\"stops execution of all test environments available in test setup.\n    \"\"\"\n    test_environments = self.get_test_environments()\n    if len(test_environments) &gt; 0:\n        for test_env_name in test_environments.keys():\n            self.log.info(f'stopping test environment \"{test_env_name}\" execution')\n            self.stop_all_test_modules_in_test_env(test_env_name)\n            self.log.info(f'completed stopping test environment \"{test_env_name}\"')\n    else:\n        self.log.info(f'Zero test environments found in configuration.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_all_test_modules_in_test_env","title":"<code>stop_all_test_modules_in_test_env(env_name)</code>","text":"<p>stops execution of all test modules available in test environment.</p> <p>Parameters:</p> Name Type Description Default <code>env_name</code> <code>str</code> <p>test environment name. avoid duplicate test environment names in CANoe configuration.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_all_test_modules_in_test_env(self, env_name: str):\n    \"\"\"stops execution of all test modules available in test environment.\n\n    Args:\n        env_name (str): test environment name. avoid duplicate test environment names in CANoe configuration.\n    \"\"\"\n    test_modules = self.get_test_modules(test_env_name=env_name)\n    if test_modules:\n        for tm_name in test_modules.keys():\n            self.stop_test_module(env_name, tm_name)\n    else:\n        self.log.info(f'test modules not available in \"{env_name}\" test environment.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_ex_measurement","title":"<code>stop_ex_measurement(timeout=60)</code>","text":"<p>StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>measurement start/stop event timeout in seconds. Defaults to 60.</p> <code>60</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if measurement stopped. else False.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_ex_measurement(self, timeout=60) -&gt; bool:\n    r\"\"\"StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.\n\n    Args:\n        timeout (int, optional): measurement start/stop event timeout in seconds. Defaults to 60.\n\n    Returns:\n        True if measurement stopped. else False.\n    \"\"\"\n    self.application.measurement.meas_start_stop_timeout = timeout\n    return self.application.measurement.stop_ex()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_measurement","title":"<code>stop_measurement(timeout=60)</code>","text":"<p>Stops the measurement.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>int</code> <p>measurement start/stop event timeout in seconds. Defaults to 60.</p> <code>60</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if measurement stopped. else False.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_measurement(self, timeout=60) -&gt; bool:\n    r\"\"\"Stops the measurement.\n\n    Args:\n        timeout (int, optional): measurement start/stop event timeout in seconds. Defaults to 60.\n\n    Returns:\n        True if measurement stopped. else False.\n    \"\"\"\n    self.application.measurement.meas_start_stop_timeout = timeout\n    return self.application.measurement.stop()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_test_module","title":"<code>stop_test_module(env_name, module_name)</code>","text":"<p>stops execution of test module.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>test module name. avoid duplicate test module names in CANoe configuration.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_test_module(self, env_name: str, module_name: str):\n    \"\"\"stops execution of test module.\n\n    Args:\n        module_name (str): test module name. avoid duplicate test module names in CANoe configuration.\n    \"\"\"\n    test_modules = self.get_test_modules(test_env_name=env_name)\n    if test_modules:\n        if module_name in test_modules.keys():\n            test_modules[module_name].stop()\n        else:\n            self.log.info(f'test module not found in \"{env_name}\" test environment.')\n    else:\n        self.log.info(f'test modules not available in \"{env_name}\" test environment.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.ui_activate_desktop","title":"<code>ui_activate_desktop(name)</code>","text":"<p>Activates the desktop with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the desktop to be activated.</p> required Source code in <code>src\\py_canoe.py</code> <pre><code>def ui_activate_desktop(self, name: str) -&gt; None:\n    r\"\"\"Activates the desktop with the given name.\n\n    Args:\n        name (str): The name of the desktop to be activated.\n    \"\"\"\n    self.application.ui.activate_desktop(name)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.ui_open_baudrate_dialog","title":"<code>ui_open_baudrate_dialog()</code>","text":"<p>opens the dialog for configuring the bus parameters. Make sure Measurement stopped when using this method.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def ui_open_baudrate_dialog(self) -&gt; None:\n    r\"\"\"opens the dialog for configuring the bus parameters. Make sure Measurement stopped when using this method.\n    \"\"\"\n    self.application.ui.open_baudrate_dialog()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.write_text_in_write_window","title":"<code>write_text_in_write_window(text)</code>","text":"<p>Outputs a line of text in the Write Window. Args:     text (str): The text.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def write_text_in_write_window(self, text: str) -&gt; None:\n    r\"\"\"Outputs a line of text in the Write Window.\n    Args:\n        text (str): The text.\n    \"\"\"\n    self.application.ui.write.output(text)\n</code></pre>"}]}