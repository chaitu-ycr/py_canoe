{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py_canoe","text":"<p>Python \ud83d\udc0d Package for controlling Vector CANoe \ud83d\udef6 Tool</p> <p>I want to thank plants \ud83c\udf8b for providing me oxygen each day. Also, I want to thank the sun \ud83c\udf04 for providing more than half of their nourishment free of charge.</p>"},{"location":"002_prerequisites/","title":"Prerequisites","text":"<ul> <li> Python(&gt;=3.9)</li> <li> Vector CANoe software(&gt;=v11)</li> <li> Windows PC(recomended win 10 os)</li> <li> visual studio code</li> </ul>"},{"location":"003_environment_setup/","title":"python environment setup","text":"<p>create python virtual environment</p> <pre><code>python -m venv .venv\n</code></pre> <p>activate virtual environment</p> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>upgrade pip</p> <pre><code>python -m pip install pip --upgrade\n</code></pre> <p>install py_canoe module</p> <pre><code>pip install py_canoe --upgrade\n</code></pre>"},{"location":"004_usage/","title":"Usage","text":""},{"location":"004_usage/#import-canoe-module","title":"Import CANoe module","text":"<pre><code># Import CANoe module\nfrom py_canoe import CANoe\n\n# create CANoe object\ncanoe_inst = CANoe()\n</code></pre>"},{"location":"004_usage/#example-use-cases","title":"Example use cases","text":"<pre><code># open CANoe configuration. Replace canoe_cfg with yours.\ncanoe_inst.open(canoe_cfg=r'tests\\demo_cfg\\demo.cfg')\n\n# print installed CANoe application version\ncanoe_inst.get_canoe_version_info()\n\n# Start CANoe measurement\ncanoe_inst.start_measurement()\n\n# get signal value. Replace arguments with your message and signal data.\nsig_val = canoe_inst.get_signal_value('CAN', 1, 'LightState', 'FlashLight')\nprint(sig_val)\n\n# set signal value. Replace arguments with your message and signal data.\ncanoe_inst.set_signal_value('CAN', 1, 'LightState', 'FlashLight', 1)\n\n# send diagnostic request. Replace arguments with your diagnostics data.\nresp = canoe_inst.send_diag_request('Door', '10 01')\nprint(resp)\n\n# Stop CANoe Measurement\ncanoe_inst.stop_measurement()\n\n# Quit / Close CANoe configuration\ncanoe_inst.quit()\n</code></pre>"},{"location":"999_reference/","title":"reference","text":"<p>Python package for controlling Vector CANoe tool</p>"},{"location":"999_reference/#src.py_canoe.CANoe","title":"<code>CANoe</code>","text":"<p>The CANoe class represents the CANoe application. The CANoe class is the foundation for the object hierarchy. You can reach all other methods from the CANoe class instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example to open CANoe configuration, start measurement, stop measurement and close configuration.\n&gt;&gt;&gt; canoe_inst = CANoe(py_canoe_log_dir=r'D:\\.py_canoe')\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(10)\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n&gt;&gt;&gt; canoe_inst.quit()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>class CANoe:\nr\"\"\"The CANoe class represents the CANoe application.\n    The CANoe class is the foundation for the object hierarchy.\n    You can reach all other methods from the CANoe class instance.\n\n    Examples:\n        &gt;&gt;&gt; # Example to open CANoe configuration, start measurement, stop measurement and close configuration.\n        &gt;&gt;&gt; canoe_inst = CANoe(py_canoe_log_dir=r'D:\\.py_canoe')\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(10)\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n        &gt;&gt;&gt; canoe_inst.quit()\n    \"\"\"\n    def __init__(self, py_canoe_log_dir='', user_capl_functions=tuple()):\n\"\"\"\n        Args:\n            py_canoe_log_dir (str): directory to store py_canoe log. example 'D:\\\\.py_canoe'\n            user_capl_functions (tuple): user defined CAPL funtions to access.\n        \"\"\"\n        pcl = PyCanoeLogger(py_canoe_log_dir)\n        self.log = pcl.log\n        self.app = Application(self.log)\n        self.meas = object\n        self.__diag_devices = dict()\n        self.user_capl_function_names = user_capl_functions\n\n    def open(self, canoe_cfg: str, visible=True, auto_save=False, prompt_user=False) -&gt; None:\nr\"\"\"Loads CANoe configuration.\n\n        Args:\n            canoe_cfg (str): The complete path for the CANoe configuration.\n            visible (bool): True if you want to see CANoe UI. Defaults to True.\n            auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n\n        Examples:\n            &gt;&gt;&gt; # The following example opens a configuration\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        \"\"\"\n        pythoncom.CoInitialize()\n        self.app.app_com_obj = win32com.client.Dispatch('CANoe.Application')\n        cav = self.app.app_com_obj.Version\n        self.log.info(f'Dispatched Vector CANoe Application {cav.major}.{cav.minor}.{cav.Build}')\n        self.app.app_com_obj.Configuration.Modified = False\n        self.app.visible = visible\n        self.app.open(path=canoe_cfg, auto_save=auto_save, prompt_user=prompt_user)\n        self.meas = Measurement(self.app, self.user_capl_function_names)\n        networks_obj = Networks(self.app)\n        self.__diag_devices = networks_obj.fetch_diag_devices()\n\n    def new(self, auto_save=False, prompt_user=False) -&gt; None:\n\"\"\"Creates a new configuration.\n\n        Args:\n            auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n\n        Examples:\n            &gt;&gt;&gt; # The following example creates a new configuration\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.new()\n        \"\"\"\n        self.app.new(auto_save, prompt_user)\n\n    def quit(self):\nr\"\"\"Quits CANoe without saving changes in the configuration.\n\n        Examples:\n            &gt;&gt;&gt; # The following example quits CANoe\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.quit()\n        \"\"\"\n        self.app.quit()\n\n    def start_measurement(self) -&gt; bool:\nr\"\"\"Starts the measurement.\n\n        Returns:\n            True if measurement started. else Flase.\n\n        Examples:\n            &gt;&gt;&gt; # The following example starts the measurement\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n        \"\"\"\n        return self.meas.start()\n\n    def stop_measurement(self) -&gt; bool:\nr\"\"\"Stops the measurement.\n\n        Returns:\n            True if measurement stopped. else Flase.\n\n        Examples:\n            &gt;&gt;&gt; # The following example stops the measurement\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n        \"\"\"\n        return self.meas.stop()\n\n    def stop_ex_measurement(self) -&gt; bool:\nr\"\"\"StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.\n\n        Returns:\n            True if measurement stopped. else Flase.\n\n        Examples:\n            &gt;&gt;&gt; # The following example full stops the measurement\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.stop_ex_measurement()\n        \"\"\"\n        return self.meas.stop_ex()\n\n    def reset_measurement(self) -&gt; bool:\nr\"\"\"reset the measurement.\n\n        Returns:\n            Measurement running status(True/False).\n\n        Examples:\n            &gt;&gt;&gt; # The following example resets the measurement\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.reset_measurement()\n        \"\"\"\n        if self.meas.running:\n            self.meas.stop()\n        self.meas.start()\n        self.log.info(f'Resetted measurement.')\n        return self.meas.running\n\n    def start_measurement_in_animation_mode(self, animation_delay=100) -&gt; None:\nr\"\"\"Starts the measurement in Animation mode.\n\n        Args:\n            animation_delay (int): The animation delay during the measurement in Offline Mode.\n\n        Examples:\n            &gt;&gt;&gt; # The following example starts the measurement in Animation mode\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement_in_animation_mode()\n        \"\"\"\n        self.meas.animation_delay = animation_delay\n        self.meas.animate()\n\n    def break_measurement_in_offline_mode(self) -&gt; None:\nr\"\"\"Interrupts the playback in Offline mode.\n\n        Examples:\n            &gt;&gt;&gt; # The following example interrupts the playback in Offline mode\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.break_measurement_in_offline_mode()\n        \"\"\"\n        self.meas.break_offline_mode()\n\n    def reset_measurement_in_offline_mode(self) -&gt; None:\nr\"\"\"Resets the measurement in Offline mode.\n\n        Examples:\n            &gt;&gt;&gt; # The following example resets the measurement in Offline mode\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.reset_measurement_in_offline_mode()\n        \"\"\"\n        self.meas.reset_offline_mode()\n\n    def step_measurement_event_in_single_step(self) -&gt; None:\nr\"\"\"Processes a measurement event in single step.\n\n        Examples:\n            &gt;&gt;&gt; # The following example processes a measurement event in single step\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.step_measurement_event_in_single_step()\n        \"\"\"\n        self.meas.step()\n\n    def get_measurement_index(self) -&gt; int:\nr\"\"\"gets the measurement index for the next measurement.\n\n        Returns:\n            Measurement Index.\n\n        Examples:\n            &gt;&gt;&gt; # The following example gets the measurement index measurement\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n            &gt;&gt;&gt; canoe_inst.get_measurement_index()\n        \"\"\"\n        self.log.info(f'measurement_index value = {self.meas.measurement_index}')\n        return self.meas.measurement_index\n\n    def set_measurement_index(self, index: int) -&gt; int:\nr\"\"\"sets the measurement index for the next measurement.\n\n        Args:\n            index (int): index value to set.\n\n        Returns:\n            Measurement Index value.\n\n        Examples:\n            &gt;&gt;&gt; # The following example sets the measurement index for the next measurement to 15\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n            &gt;&gt;&gt; canoe_inst.set_measurement_index(15)\n        \"\"\"\n        self.meas.measurement_index = index\n        return self.meas.measurement_index\n\n    def get_measurement_running_status(self) -&gt; bool:\nr\"\"\"Returns the running state of the measurement.\n\n        Returns:\n            True if The measurement is running.\n            False if The measurement is not running.\n\n        Examples:\n            &gt;&gt;&gt; # The following example returns measurement running status (True/False)\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.get_measurement_running_status()\n        \"\"\"\n        self.log.info(f'CANoe Measurement Running Status = {self.meas.running}')\n        return self.meas.running\n\n    def save_configuration(self) -&gt; bool:\nr\"\"\"Saves the configuration.\n\n        Returns:\n            True if configuration saved. else False.\n\n        Examples:\n            &gt;&gt;&gt; # The following example saves the configuration if necessary\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.save_configuration()\n        \"\"\"\n        conf_obj = Configuration(self.app)\n        return conf_obj.save()\n\n    def save_configuration_as(self, path: str, major: int, minor: int, create_dir=True) -&gt; bool:\nr\"\"\"Saves the configuration as a different CANoe version.\n\n        Args:\n            path (str): The complete file name.\n            major (int): The major version number of the target version.\n            minor (int): The minor version number of the target version.\n            create_dir (bool): create dirrectory if not available. default value True.\n\n        Returns:\n            True if configuration saved. else False.\n\n        Examples:\n            &gt;&gt;&gt; # The following example saves the configuration as a CANoe 10.0 version\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.save_configuration_as(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo_v12.cfg', 10, 0)\"\"\"\n        conf_obj = Configuration(self.app)\n        config_path = '\\\\'.join(path.split('\\\\')[:-1])\n        if not os.path.exists(config_path) and create_dir:\n            os.makedirs(config_path, exist_ok=True)\n        if os.path.exists(config_path):\n            conf_obj.save_as(path, major, minor, False)\n            return conf_obj.saved\n        else:\n            self.log.info(f'tried creating {path}. but {config_path} directory not found.')\n            return False\n\n    def get_signal_value(self, bus: str, channel: int, message: str, signal: str, raw_value=False) -&gt; Union[float, int]:\nr\"\"\"get_signal_value Returns a Signal value.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Returns:\n            signal vaue.\n\n        Examples:\n            &gt;&gt;&gt; # The following example gets signal value\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; sig_val = canoe_inst.get_signal_value('CAN', 1, 'LightState', 'FlashLight')\n            &gt;&gt;&gt; print(sig_val)\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n        signal_value = sig_obj.raw_value if raw_value else sig_obj.value\n        self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n        return signal_value\n\n    def set_signal_value(self, bus: str, channel: int, message: str, signal: str, value: int, raw_value=False) -&gt; None:\nr\"\"\"set_signal_value sets a value to Signal. Works only when messages are sent using CANoe IL.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            value (Union[float, int]): signal value.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Examples:\n            &gt;&gt;&gt; # The following example sets signal value to 1\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.set_signal_value('CAN', 1, 'LightState', 'FlashLight', 1)\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n        if raw_value:\n            sig_obj.raw_value = value\n        else:\n            sig_obj.value = value\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n\n    def get_signal_full_name(self, bus: str, channel: int, message: str, signal: str) -&gt; str:\n\"\"\"Determines the fully qualified name of a signal.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n        return sig_obj.full_name\n\n    def check_signal_online(self, bus: str, channel: int, message: str, signal: str) -&gt; bool:\nr\"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            TRUE if the measurement is running and the signal has been received. FALSE if not.\n\n        Examples:\n            &gt;&gt;&gt; # The following example checks signal is online.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.check_signal_online('CAN', 1, 'LightState', 'FlashLight')\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n        sig_online_status = sig_obj.is_online\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) online status = {sig_online_status}.')\n        return sig_online_status\n\n    def check_signal_state(self, bus: str, channel: int, message: str, signal: str) -&gt; int:\nr\"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            State of the signal.\n            0 The default value of the signal is returned.\n            1 The measurement is not running; the value set by the application is returned.\n            2 The measurement is not running; the value of the last measurement is returned.\n            3 The signal has been received in the current measurement; the current value is returned.\n\n        Examples:\n            &gt;&gt;&gt; # The following example checks signal state.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.check_signal_state('CAN', 1, 'LightState', 'FlashLight')\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n        sig_state = sig_obj.state\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) state = {sig_state}.')\n        return sig_state\n\n    def get_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int,\n                               raw_value=False) -&gt; Union[float, int]:\nr\"\"\"get_j1939_signal Returns a Signal object.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Returns:\n            signal vaue.\n\n        Examples:\n            &gt;&gt;&gt; # The following example gets j1939 signal value\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; sig_val = canoe_inst.get_j1939_signal_value('CAN', 1, 'LightState', 'FlashLight', 0, 1)\n            &gt;&gt;&gt; print(sig_val)\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n        signal_value = sig_obj.raw_value if raw_value else sig_obj.value\n        self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n        return signal_value\n\n    def set_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int, value: Union[float, int],\n                               raw_value=False) -&gt; None:\nr\"\"\"get_j1939_signal Returns a Signal object.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n            value (Union[float, int]): signal value.\n            raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n        Returns:\n            signal vaue.\n\n        Examples:\n            &gt;&gt;&gt; # The following example gets j1939 signal value\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.set_j1939_signal_value('CAN', 1, 'LightState', 'FlashLight', 0, 1, 1)\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n        if raw_value:\n            sig_obj.raw_value = value\n        else:\n            sig_obj.value = value\n        self.log.info(f'signal value set to {value}.')\n        self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n\n    def get_j1939_signal_full_name(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; str:\n\"\"\"Determines the fully qualified name of a signal.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n\n        Returns:\n            str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n        return sig_obj.full_name\n\n    def check_j1939_signal_online(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; bool:\n\"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Args:\n            bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_addr (int): The source address of the ECU that sends the message.\n            dest_addr (int): The destination address of the ECU that receives the message.\n\n        Returns:\n            bool: TRUE: if the measurement is running and the signal has been received. FALSE: if not.\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n        return sig_obj.is_online\n\n    def check_j1939_signal_state(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; int:\n\"\"\"Returns the state of the signal.\n\n        Returns:\n            int: State of the signal; possible values are: 0: The default value of the signal is returned. 1: The measurement is not running; the value set by the application is returned. 3: The signal has been received in the current measurement; the current value is returned.\n        \"\"\"\n        bus_obj = Bus(self.app, bus_type=bus)\n        sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n        return sig_obj.state\n\n    def ui_activate_desktop(self, name: str) -&gt; None:\nr\"\"\"Activates the desktop with the given name.\n\n        Args:\n            name (str): The name of the desktop to be activated.\n\n        Examples:\n            &gt;&gt;&gt; # The following example switches to the desktop with the name \"Configuration\"\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.ui_activate_desktop(\"Configuration\")\n        \"\"\"\n        ui_obj = Ui(self.app)\n        ui_obj.activate_desktop(name)\n\n    def ui_open_baudrate_dialog(self) -&gt; None:\nr\"\"\"opens the dialog for configuring the bus parameters. Make sure Measurement stopped when using this method.\n\n        Examples:\n            &gt;&gt;&gt; # The following example opens the dialog for configuring the bus parameters\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n            &gt;&gt;&gt; canoe_inst.ui_open_baudrate_dialog()\n        \"\"\"\n        ui_obj = Ui(self.app)\n        ui_obj.open_baudrate_dialog()\n\n    def write_text_in_write_window(self, text: str) -&gt; None:\nr\"\"\"Outputs a line of text in the Write Window.\n        Args:\n            text (str): The text.\n\n        Examples:\n            &gt;&gt;&gt; # The following example Outputs a line of text in the Write Window.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; print(canoe_inst.read_text_from_write_window())\n        \"\"\"\n        ui_obj = Ui(self.app)\n        ui_obj.send_text_to_write_window(text)\n\n    def read_text_from_write_window(self) -&gt; str:\nr\"\"\"read the text contents from Write Window.\n\n        Returns:\n            The text content.\n\n        Examples:\n            &gt;&gt;&gt; # The following example reads text from Write Window.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; print(canoe_inst.read_text_from_write_window())\n        \"\"\"\n        ui_obj = Ui(self.app)\n        return ui_obj.get_write_window_text_content()\n\n    def clear_write_window_content(self) -&gt; None:\nr\"\"\"Clears the contents of the Write Window.\n\n        Examples:\n            &gt;&gt;&gt; # The following example clears content from Write Window.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; canoe_inst.clear_write_window_content()\n        \"\"\"\n        ui_obj = Ui(self.app)\n        ui_obj.clear_write_window_content()\n\n    def enable_write_window_output_file(self, output_file: str) -&gt; None:\nr\"\"\"Enables logging of all outputs of the Write Window in the output file.\n\n        Args:\n            output_file (str): The complete path of the output file.\n\n        Examples:\n            &gt;&gt;&gt; # The following example Enables logging of all outputs of the Write Window in the output file.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.enable_write_window_output_file(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\write_out.txt')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n        \"\"\"\n        ui_obj = Ui(self.app)\n        ui_obj.enable_write_window_logging(output_file)\n\n    def disable_write_window_output_file(self) -&gt; None:\nr\"\"\"Disables logging of all outputs of the Write Window.\n\n        Examples:\n            &gt;&gt;&gt; # The following example Disables logging of all outputs of the Write Window.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.disable_write_window_output_file()\n        \"\"\"\n        ui_obj = Ui(self.app)\n        ui_obj.disable_write_window_logging()\n\n    def get_can_bus_statistics(self, channel: int) -&gt; dict:\nr\"\"\"Returns CAN Bus Statistics.\n\n        Args:\n            channel (int): The channel of the statistic that is to be returned.\n\n        Returns:\n            CAN bus statistics.\n\n        Examples:\n            &gt;&gt;&gt; # The following example prints CAN channel 1 statistics\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; print(canoe_inst.get_can_bus_statistics(channel=1))\n        \"\"\"\n        conf_obj = Configuration(self.app)\n        bus_types = {'CAN': 1, 'J1939': 2, 'TTP': 4, 'LIN': 5, 'MOST': 6, 'Kline': 14}\n        bus_statistics_obj = conf_obj.conf_com_obj.OnlineSetup.BusStatistics.BusStatistic(bus_types['CAN'], channel)\n        statistics_info = {\n            # The bus load\n            'bus_load': bus_statistics_obj.BusLoad,\n            # The controller status\n            'chip_state': bus_statistics_obj.ChipState,\n            # The number of Error Frames per second\n            'error': bus_statistics_obj.Error,\n            # The total number of Error Frames\n            'error_total': bus_statistics_obj.ErrorTotal,\n            # The number of messages with extended identifier per second\n            'extended': bus_statistics_obj.Extended,\n            # The total number of messages with extended identifier\n            'extended': bus_statistics_obj.ExtendedTotal,\n            # The number of remote messages with extended identifier per second\n            'extended_remote': bus_statistics_obj.ExtendedRemote,\n            # The total number of remote messages with extended identifier\n            'extended_remote_total': bus_statistics_obj.ExtendedRemoteTotal,\n            # The number of overload frames per second\n            'overload': bus_statistics_obj.Overload,\n            # The total number of overload frames\n            'overload_total': bus_statistics_obj.OverloadTotal,\n            # The maximum bus load in 0.01 %\n            'peak_load': bus_statistics_obj.PeakLoad,\n            # Returns the current number of the Rx error counter\n            'rx_error_count': bus_statistics_obj.RxErrorCount,\n            # The number of messages with standard identifier per second\n            'standard': bus_statistics_obj.Standard,\n            # The total number of remote messages with standard identifier\n            'standard_total': bus_statistics_obj.StandardTotal,\n            # The number of remote messages with standard identifier per second\n            'standard_remote': bus_statistics_obj.StandardRemote,\n            # The total number of remote messages with standard identifier\n            'standard_remote_total': bus_statistics_obj.StandardRemoteTotal,\n            # The current number of the Tx error counter\n            'tx_error_count': bus_statistics_obj.TxErrorCount,\n        }\n        self.log.info(f'CAN Bus Statistics: {statistics_info}.')\n        return statistics_info\n\n    def get_canoe_version_info(self) -&gt; dict:\nr\"\"\"The Version class represents the version of the CANoe application.\n\n        Returns:\n            \"full_name\" - The complete CANoe version.\n            \"name\" - The CANoe version.\n            \"build\" - The build number of the CANoe application.\n            \"major\" - The major version number of the CANoe application.\n            \"minor\" - The minor version number of the CANoe application.\n            \"patch\" - The patch number of the CANoe application.\n\n        Examples:\n            &gt;&gt;&gt; # The following example returns CANoe application version relevant information.\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_version_info = canoe_inst.get_canoe_version_info()\n            &gt;&gt;&gt; print(canoe_version_info)\n        \"\"\"\n        ver_obj = Version(self.app)\n        version_info = {'full_name': ver_obj.full_name,\n                        'name': ver_obj.name,\n                        'build': ver_obj.build,\n                        'major': ver_obj.major,\n                        'minor': ver_obj.minor,\n                        'patch': ver_obj.patch}\n        self.log.info('&gt; CANoe Application.Version &lt;'.center(100, '='))\n        for k, v in version_info.items():\n            self.log.info(f'{k:&lt;10}: {v}')\n        self.log.info(''.center(100, '='))\n        return version_info\n\n    def define_system_variable(self, sys_var_name: str, value=0) -&gt; object:\nr\"\"\"define_system_variable Create a system variable with an initial value\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n            value (Union[int, float, str]): variable value. Default value 0.\n\n        Returns:\n            object: The new Variable object.\n\n        Examples:\n            &gt;&gt;&gt; # The following example gets system variable value\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.define_system_variable('sys_demo::speed', 1)\n        \"\"\"\n        namespace = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        new_var_obj = None\n        try:\n            sys_obj = System(self.app)\n            namespaces_obj = Namespaces(win32com.client.Dispatch(sys_obj.sys_com_obj.Namespaces))\n            new_namespace_obj = namespaces_obj.add(namespace)\n            vars_obj = Variables(new_namespace_obj.Variables)\n            new_var_obj = vars_obj.add(variable_name, value)\n            self.log.info(f'system variable({sys_var_name}) created and value set to {value}.')\n        except Exception as e:\n            self.log.info(f'failed to create system variable({sys_var_name}). {e}')\n        return new_var_obj\n\n    def get_system_variable_value(self, sys_var_name: str) -&gt; Union[int, float, str, None]:\nr\"\"\"get_system_variable_value Returns a system variable value.\n\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n\n        Returns:\n            System Variable value.\n\n        Examples:\n            &gt;&gt;&gt; # The following example gets system variable value\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; sys_var_val = canoe_inst.get_system_variable_value('sys_var_demo::speed')\n            &gt;&gt;&gt;print(sys_var_val)\n        \"\"\"\n        namespace = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        return_value = None\n        try:\n            sys_obj = System(self.app)\n            namespace_object = sys_obj.sys_com_obj.Namespaces(namespace)\n            return_value = namespace_object.Variables(variable_name).Value\n            self.log.info(f'system variable({sys_var_name}) value = {return_value}.')\n        except Exception as e:\n            self.log.info(f'failed to get system variable({sys_var_name}) value. {e}')\n        return return_value\n\n    def set_system_variable_value(self, sys_var_name: str, value: Union[int, float, str]) -&gt; None:\nr\"\"\"set_system_variable_value sets a value to system variable.\n\n        Args:\n            sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n            value (Union[int, float, str]): variable value.\n\n        Examples:\n            &gt;&gt;&gt; # The following example sets system variable value to 1\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.set_system_variable_value('sys_var_demo::speed', 1)\n        \"\"\"\n        namespace = '::'.join(sys_var_name.split('::')[:-1])\n        variable_name = sys_var_name.split('::')[-1]\n        try:\n            sys_obj = System(self.app)\n            namespace_object = sys_obj.sys_com_obj.Namespaces(namespace)\n            namespace_object.Variables(variable_name).Value = value\n            self.log.info(f'system variable({sys_var_name}) value set to {value}.')\n        except Exception as e:\n            self.log.info(f'failed to set system variable({sys_var_name}) value. {e}')\n\n    def send_diag_request(self, diag_ecu_qualifier_name: str, request: str, request_in_bytes=True) -&gt; str:\nr\"\"\"The send_diag_request method represents the query of a diagnostic tester (client) to an ECU (server) in CANoe.\n\n        Args:\n            diag_ecu_qualifier_name (str): Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".\n            request (str): Diagnostic request in bytes or diagnostic node qualifier name.\n            request_in_bytes (bool): True if Diagnostic request is bytes. False if you are using Qualifier name. Default is True.\n\n        Returns:\n            diagnostic response stream. Ex- \"50 01 00 00 00 00\"\n\n        Examples:\n            &gt;&gt;&gt; # Example 1 - The following example sends diagnostic request \"10 01\"\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; resp = canoe_inst.send_diag_request('Door', '10 01')\n            &gt;&gt;&gt; print(resp)\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n            &gt;&gt;&gt; # Example 2 - The following example sends diagnostic request \"DefaultSession_Start\"\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(canoe_cfg=r'C:\\Users\\Public\\Documents\\Vector\\CANoe\\Sample Configurations 11.0.81\\.\\CAN\\Diagnostics\\UDSBasic\\UDSBasic.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; wait(1)\n            &gt;&gt;&gt; resp = canoe_inst.send_diag_request('Door', 'DefaultSession_Start', False)\n            &gt;&gt;&gt; print(resp)\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n        \"\"\"\n        diag_response_data = \"\"\n        try:\n            if diag_ecu_qualifier_name in self.__diag_devices.keys():\n                self.log.info(f'Diag Req --&gt; {request}')\n                if request_in_bytes:\n                    diag_req_in_bytes = bytearray()\n                    request = ''.join(request.split(' '))\n                    for i in range(0, len(request), 2):\n                        diag_req_in_bytes.append(int(request[i:i + 2], 16))\n                    diag_req = self.__diag_devices[diag_ecu_qualifier_name].CreateRequestFromStream(diag_req_in_bytes)\n                else:\n                    diag_req = self.__diag_devices[diag_ecu_qualifier_name].CreateRequest(request)\n                diag_req.Send()\n                while diag_req.Pending:\n                    wait(0.1)\n                if diag_req.Responses.Count == 0:\n                    self.log.info(\"Diagnostic Response Not Received.\")\n                else:\n                    for k in range(1, diag_req.Responses.Count + 1):\n                        diag_res = diag_req.Responses(k)\n                        if diag_res.Positive:\n                            self.log.info(f\"+ve response received.\")\n                        else:\n                            self.log.info(f\"-ve response received.\")\n                        diag_response_data = \" \".join(f\"{d:02X}\" for d in diag_res.Stream).upper()\n                    self.log.info(f'Diag Res --&gt; {diag_response_data}')\n            else:\n                self.log.info(f'Diag ECU qualifier({diag_ecu_qualifier_name}) not available in loaded CANoe config.')\n        except Exception as e:\n            self.log.info(f'failed to send diag request({request}). {e}')\n        return diag_response_data\n\n    def __fetch_replay_blocks(self) -&gt; dict:\n        replay_blocks = dict()\n        try:\n            bus_obj = Bus(self.app)\n            for replay_block in bus_obj.ReplayCollection:\n                replay_blocks[replay_block.Name] = replay_block\n        except Exception as e:\n            self.log.info(f'failed to fetch replay blocks. {e}')\n        return replay_blocks\n\n    def set_replay_block_file(self, block_name: str, recording_file_path: str) -&gt; None:\nr\"\"\"Method for setting CANoe replay block file.\n\n        Args:\n            block_name: CANoe replay block name\n            recording_file_path: CANoe replay recording file including path.\n\n        Examples:\n            &gt;&gt;&gt; # The following example sets replay block file\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.set_replay_block_file(block_name='replay block name', recording_file_path='replay file including path')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n        \"\"\"\n        replay_blocks = self.__fetch_replay_blocks()\n        if block_name in replay_blocks.keys():\n            replay_blocks[block_name].Path = recording_file_path\n            self.log.info(f'Replay block \"{block_name}\" updated with \"{recording_file_path}\" path.')\n        else:\n            self.log.warning(f'Replay block \"{block_name}\" not available.')\n\n    def control_replay_block(self, block_name: str, start_stop: bool) -&gt; None:\nr\"\"\"Method for setting CANoe replay block file.\n\n        Args:\n            block_name (str): CANoe replay block name\n            start_stop (bool): True to start replay block. False to Stop.\n\n        Examples:\n            &gt;&gt;&gt; # The following example starts replay block\n            &gt;&gt;&gt; canoe_inst = CANoe()\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.set_replay_block_file(block_name='replay block name', recording_file_path='replay file including path')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.control_replay_block('replay block name', True)\n        \"\"\"\n        replay_blocks = self.__fetch_replay_blocks()\n        if block_name in replay_blocks.keys():\n            if start_stop:\n                replay_blocks[block_name].Start()\n            else:\n                replay_blocks[block_name].Stop()\n            self.log.info(f'Replay block \"{block_name}\" {\"Started\" if start_stop else \"Stopped\"}.')\n        else:\n            self.log.warning(f'Replay block \"{block_name}\" not available.')\n\n    def compile_all_capl_nodes(self) -&gt; None:\nr\"\"\"compiles all CAPL, XML and .NET nodes.\n        \"\"\"\n        capl_obj = Capl(self.app)\n        capl_obj.compile()\n        self.log.info(f'compiled all nodes successfully.')\n\n    def call_capl_function(self, name: str, *arguments) -&gt; bool:\nr\"\"\"Calls a CAPL function.\n        Please note that the number of parameters must agree with that of the CAPL function.\n        not possible to read return value of CAPL function at the moment. only execution status is returned.\n\n        Args:\n            name (str): The name of the CAPL function. Please make sure this name is already passed as argument during CANoe instance creation. see example for more info.\n            arguments (tuple): Function parameters p1\u2026p10 (optional).\n\n        Returns:\n            bool: CAPL function execution status. True-success, False-failed.\n\n        Examples:\n            &gt;&gt;&gt; # The following example starts replay block\n            &gt;&gt;&gt; canoe_inst = CANoe(user_capl_functions=('addition_function', ))\n            &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n            &gt;&gt;&gt; canoe_inst.start_measurement()\n            &gt;&gt;&gt; canoe_inst.call_capl_function('addition_function', 100, 200)\n            &gt;&gt;&gt; canoe_inst.stop_measurement()\n        \"\"\"\n        capl_obj = Capl(self.app)\n        exec_sts = capl_obj.call_capl_function(self.meas.user_capl_function_obj_dict[name], *arguments)\n        self.log.info(f'triggered capl function({name}). execution status = {exec_sts}.')\n        return exec_sts\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.__init__","title":"<code>__init__(py_canoe_log_dir='', user_capl_functions=tuple())</code>","text":"<p>Parameters:</p> Name Type Description Default <code>py_canoe_log_dir</code> <code>str</code> <p>directory to store py_canoe log. example 'D:.py_canoe'</p> <code>''</code> <code>user_capl_functions</code> <code>tuple</code> <p>user defined CAPL funtions to access.</p> <code>tuple()</code> Source code in <code>src\\py_canoe.py</code> <pre><code>def __init__(self, py_canoe_log_dir='', user_capl_functions=tuple()):\n\"\"\"\n    Args:\n        py_canoe_log_dir (str): directory to store py_canoe log. example 'D:\\\\.py_canoe'\n        user_capl_functions (tuple): user defined CAPL funtions to access.\n    \"\"\"\n    pcl = PyCanoeLogger(py_canoe_log_dir)\n    self.log = pcl.log\n    self.app = Application(self.log)\n    self.meas = object\n    self.__diag_devices = dict()\n    self.user_capl_function_names = user_capl_functions\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.break_measurement_in_offline_mode","title":"<code>break_measurement_in_offline_mode()</code>","text":"<p>Interrupts the playback in Offline mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example interrupts the playback in Offline mode\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.break_measurement_in_offline_mode()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def break_measurement_in_offline_mode(self) -&gt; None:\nr\"\"\"Interrupts the playback in Offline mode.\n\n    Examples:\n        &gt;&gt;&gt; # The following example interrupts the playback in Offline mode\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.break_measurement_in_offline_mode()\n    \"\"\"\n    self.meas.break_offline_mode()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.call_capl_function","title":"<code>call_capl_function(name, *arguments)</code>","text":"<p>Calls a CAPL function. Please note that the number of parameters must agree with that of the CAPL function. not possible to read return value of CAPL function at the moment. only execution status is returned.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the CAPL function. Please make sure this name is already passed as argument during CANoe instance creation. see example for more info.</p> required <code>arguments</code> <code>tuple</code> <p>Function parameters p1\u2026p10 (optional).</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>CAPL function execution status. True-success, False-failed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example starts replay block\n&gt;&gt;&gt; canoe_inst = CANoe(user_capl_functions=('addition_function', ))\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.call_capl_function('addition_function', 100, 200)\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def call_capl_function(self, name: str, *arguments) -&gt; bool:\nr\"\"\"Calls a CAPL function.\n    Please note that the number of parameters must agree with that of the CAPL function.\n    not possible to read return value of CAPL function at the moment. only execution status is returned.\n\n    Args:\n        name (str): The name of the CAPL function. Please make sure this name is already passed as argument during CANoe instance creation. see example for more info.\n        arguments (tuple): Function parameters p1\u2026p10 (optional).\n\n    Returns:\n        bool: CAPL function execution status. True-success, False-failed.\n\n    Examples:\n        &gt;&gt;&gt; # The following example starts replay block\n        &gt;&gt;&gt; canoe_inst = CANoe(user_capl_functions=('addition_function', ))\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.call_capl_function('addition_function', 100, 200)\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n    \"\"\"\n    capl_obj = Capl(self.app)\n    exec_sts = capl_obj.call_capl_function(self.meas.user_capl_function_obj_dict[name], *arguments)\n    self.log.info(f'triggered capl function({name}). execution status = {exec_sts}.')\n    return exec_sts\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_j1939_signal_online","title":"<code>check_j1939_signal_online(bus, channel, message, signal, source_addr, dest_addr)</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>TRUE: if the measurement is running and the signal has been received. FALSE: if not.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_j1939_signal_online(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; bool:\n\"\"\"Checks whether the measurement is running and the signal has been received.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n\n    Returns:\n        bool: TRUE: if the measurement is running and the signal has been received. FALSE: if not.\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n    return sig_obj.is_online\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_j1939_signal_state","title":"<code>check_j1939_signal_state(bus, channel, message, signal, source_addr, dest_addr)</code>","text":"<p>Returns the state of the signal.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>State of the signal; possible values are: 0: The default value of the signal is returned. 1: The measurement is not running; the value set by the application is returned. 3: The signal has been received in the current measurement; the current value is returned.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_j1939_signal_state(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; int:\n\"\"\"Returns the state of the signal.\n\n    Returns:\n        int: State of the signal; possible values are: 0: The default value of the signal is returned. 1: The measurement is not running; the value set by the application is returned. 3: The signal has been received in the current measurement; the current value is returned.\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n    return sig_obj.state\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_signal_online","title":"<code>check_signal_online(bus, channel, message, signal)</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>TRUE if the measurement is running and the signal has been received. FALSE if not.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example checks signal is online.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.check_signal_online('CAN', 1, 'LightState', 'FlashLight')\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_signal_online(self, bus: str, channel: int, message: str, signal: str) -&gt; bool:\nr\"\"\"Checks whether the measurement is running and the signal has been received.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        TRUE if the measurement is running and the signal has been received. FALSE if not.\n\n    Examples:\n        &gt;&gt;&gt; # The following example checks signal is online.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.check_signal_online('CAN', 1, 'LightState', 'FlashLight')\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n    sig_online_status = sig_obj.is_online\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) online status = {sig_online_status}.')\n    return sig_online_status\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.check_signal_state","title":"<code>check_signal_state(bus, channel, message, signal)</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Type Description <code>int</code> <p>State of the signal.</p> <code>int</code> <p>0 The default value of the signal is returned.</p> <code>int</code> <p>1 The measurement is not running; the value set by the application is returned.</p> <code>int</code> <p>2 The measurement is not running; the value of the last measurement is returned.</p> <code>int</code> <p>3 The signal has been received in the current measurement; the current value is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example checks signal state.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.check_signal_state('CAN', 1, 'LightState', 'FlashLight')\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def check_signal_state(self, bus: str, channel: int, message: str, signal: str) -&gt; int:\nr\"\"\"Checks whether the measurement is running and the signal has been received.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        State of the signal.\n        0 The default value of the signal is returned.\n        1 The measurement is not running; the value set by the application is returned.\n        2 The measurement is not running; the value of the last measurement is returned.\n        3 The signal has been received in the current measurement; the current value is returned.\n\n    Examples:\n        &gt;&gt;&gt; # The following example checks signal state.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.check_signal_state('CAN', 1, 'LightState', 'FlashLight')\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n    sig_state = sig_obj.state\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) state = {sig_state}.')\n    return sig_state\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.clear_write_window_content","title":"<code>clear_write_window_content()</code>","text":"<p>Clears the contents of the Write Window.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example clears content from Write Window.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; canoe_inst.clear_write_window_content()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def clear_write_window_content(self) -&gt; None:\nr\"\"\"Clears the contents of the Write Window.\n\n    Examples:\n        &gt;&gt;&gt; # The following example clears content from Write Window.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; canoe_inst.clear_write_window_content()\n    \"\"\"\n    ui_obj = Ui(self.app)\n    ui_obj.clear_write_window_content()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.compile_all_capl_nodes","title":"<code>compile_all_capl_nodes()</code>","text":"<p>compiles all CAPL, XML and .NET nodes.</p> Source code in <code>src\\py_canoe.py</code> <pre><code>def compile_all_capl_nodes(self) -&gt; None:\nr\"\"\"compiles all CAPL, XML and .NET nodes.\n    \"\"\"\n    capl_obj = Capl(self.app)\n    capl_obj.compile()\n    self.log.info(f'compiled all nodes successfully.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.control_replay_block","title":"<code>control_replay_block(block_name, start_stop)</code>","text":"<p>Method for setting CANoe replay block file.</p> <p>Parameters:</p> Name Type Description Default <code>block_name</code> <code>str</code> <p>CANoe replay block name</p> required <code>start_stop</code> <code>bool</code> <p>True to start replay block. False to Stop.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example starts replay block\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.set_replay_block_file(block_name='replay block name', recording_file_path='replay file including path')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.control_replay_block('replay block name', True)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def control_replay_block(self, block_name: str, start_stop: bool) -&gt; None:\nr\"\"\"Method for setting CANoe replay block file.\n\n    Args:\n        block_name (str): CANoe replay block name\n        start_stop (bool): True to start replay block. False to Stop.\n\n    Examples:\n        &gt;&gt;&gt; # The following example starts replay block\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.set_replay_block_file(block_name='replay block name', recording_file_path='replay file including path')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.control_replay_block('replay block name', True)\n    \"\"\"\n    replay_blocks = self.__fetch_replay_blocks()\n    if block_name in replay_blocks.keys():\n        if start_stop:\n            replay_blocks[block_name].Start()\n        else:\n            replay_blocks[block_name].Stop()\n        self.log.info(f'Replay block \"{block_name}\" {\"Started\" if start_stop else \"Stopped\"}.')\n    else:\n        self.log.warning(f'Replay block \"{block_name}\" not available.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.define_system_variable","title":"<code>define_system_variable(sys_var_name, value=0)</code>","text":"<p>define_system_variable Create a system variable with an initial value Args:     sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"     value (Union[int, float, str]): variable value. Default value 0.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Variable object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example gets system variable value\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.define_system_variable('sys_demo::speed', 1)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def define_system_variable(self, sys_var_name: str, value=0) -&gt; object:\nr\"\"\"define_system_variable Create a system variable with an initial value\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n        value (Union[int, float, str]): variable value. Default value 0.\n\n    Returns:\n        object: The new Variable object.\n\n    Examples:\n        &gt;&gt;&gt; # The following example gets system variable value\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.define_system_variable('sys_demo::speed', 1)\n    \"\"\"\n    namespace = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    new_var_obj = None\n    try:\n        sys_obj = System(self.app)\n        namespaces_obj = Namespaces(win32com.client.Dispatch(sys_obj.sys_com_obj.Namespaces))\n        new_namespace_obj = namespaces_obj.add(namespace)\n        vars_obj = Variables(new_namespace_obj.Variables)\n        new_var_obj = vars_obj.add(variable_name, value)\n        self.log.info(f'system variable({sys_var_name}) created and value set to {value}.')\n    except Exception as e:\n        self.log.info(f'failed to create system variable({sys_var_name}). {e}')\n    return new_var_obj\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.disable_write_window_output_file","title":"<code>disable_write_window_output_file()</code>","text":"<p>Disables logging of all outputs of the Write Window.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example Disables logging of all outputs of the Write Window.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.disable_write_window_output_file()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def disable_write_window_output_file(self) -&gt; None:\nr\"\"\"Disables logging of all outputs of the Write Window.\n\n    Examples:\n        &gt;&gt;&gt; # The following example Disables logging of all outputs of the Write Window.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.disable_write_window_output_file()\n    \"\"\"\n    ui_obj = Ui(self.app)\n    ui_obj.disable_write_window_logging()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.enable_write_window_output_file","title":"<code>enable_write_window_output_file(output_file)</code>","text":"<p>Enables logging of all outputs of the Write Window in the output file.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str</code> <p>The complete path of the output file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example Enables logging of all outputs of the Write Window in the output file.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.enable_write_window_output_file(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\write_out.txt')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def enable_write_window_output_file(self, output_file: str) -&gt; None:\nr\"\"\"Enables logging of all outputs of the Write Window in the output file.\n\n    Args:\n        output_file (str): The complete path of the output file.\n\n    Examples:\n        &gt;&gt;&gt; # The following example Enables logging of all outputs of the Write Window in the output file.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.enable_write_window_output_file(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\write_out.txt')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n    \"\"\"\n    ui_obj = Ui(self.app)\n    ui_obj.enable_write_window_logging(output_file)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_can_bus_statistics","title":"<code>get_can_bus_statistics(channel)</code>","text":"<p>Returns CAN Bus Statistics.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel of the statistic that is to be returned.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>CAN bus statistics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example prints CAN channel 1 statistics\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; print(canoe_inst.get_can_bus_statistics(channel=1))\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_can_bus_statistics(self, channel: int) -&gt; dict:\nr\"\"\"Returns CAN Bus Statistics.\n\n    Args:\n        channel (int): The channel of the statistic that is to be returned.\n\n    Returns:\n        CAN bus statistics.\n\n    Examples:\n        &gt;&gt;&gt; # The following example prints CAN channel 1 statistics\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; print(canoe_inst.get_can_bus_statistics(channel=1))\n    \"\"\"\n    conf_obj = Configuration(self.app)\n    bus_types = {'CAN': 1, 'J1939': 2, 'TTP': 4, 'LIN': 5, 'MOST': 6, 'Kline': 14}\n    bus_statistics_obj = conf_obj.conf_com_obj.OnlineSetup.BusStatistics.BusStatistic(bus_types['CAN'], channel)\n    statistics_info = {\n        # The bus load\n        'bus_load': bus_statistics_obj.BusLoad,\n        # The controller status\n        'chip_state': bus_statistics_obj.ChipState,\n        # The number of Error Frames per second\n        'error': bus_statistics_obj.Error,\n        # The total number of Error Frames\n        'error_total': bus_statistics_obj.ErrorTotal,\n        # The number of messages with extended identifier per second\n        'extended': bus_statistics_obj.Extended,\n        # The total number of messages with extended identifier\n        'extended': bus_statistics_obj.ExtendedTotal,\n        # The number of remote messages with extended identifier per second\n        'extended_remote': bus_statistics_obj.ExtendedRemote,\n        # The total number of remote messages with extended identifier\n        'extended_remote_total': bus_statistics_obj.ExtendedRemoteTotal,\n        # The number of overload frames per second\n        'overload': bus_statistics_obj.Overload,\n        # The total number of overload frames\n        'overload_total': bus_statistics_obj.OverloadTotal,\n        # The maximum bus load in 0.01 %\n        'peak_load': bus_statistics_obj.PeakLoad,\n        # Returns the current number of the Rx error counter\n        'rx_error_count': bus_statistics_obj.RxErrorCount,\n        # The number of messages with standard identifier per second\n        'standard': bus_statistics_obj.Standard,\n        # The total number of remote messages with standard identifier\n        'standard_total': bus_statistics_obj.StandardTotal,\n        # The number of remote messages with standard identifier per second\n        'standard_remote': bus_statistics_obj.StandardRemote,\n        # The total number of remote messages with standard identifier\n        'standard_remote_total': bus_statistics_obj.StandardRemoteTotal,\n        # The current number of the Tx error counter\n        'tx_error_count': bus_statistics_obj.TxErrorCount,\n    }\n    self.log.info(f'CAN Bus Statistics: {statistics_info}.')\n    return statistics_info\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_canoe_version_info","title":"<code>get_canoe_version_info()</code>","text":"<p>The Version class represents the version of the CANoe application.</p> <p>Returns:</p> Type Description <code>dict</code> <p>\"full_name\" - The complete CANoe version.</p> <code>dict</code> <p>\"name\" - The CANoe version.</p> <code>dict</code> <p>\"build\" - The build number of the CANoe application.</p> <code>dict</code> <p>\"major\" - The major version number of the CANoe application.</p> <code>dict</code> <p>\"minor\" - The minor version number of the CANoe application.</p> <code>dict</code> <p>\"patch\" - The patch number of the CANoe application.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example returns CANoe application version relevant information.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_version_info = canoe_inst.get_canoe_version_info()\n&gt;&gt;&gt; print(canoe_version_info)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_canoe_version_info(self) -&gt; dict:\nr\"\"\"The Version class represents the version of the CANoe application.\n\n    Returns:\n        \"full_name\" - The complete CANoe version.\n        \"name\" - The CANoe version.\n        \"build\" - The build number of the CANoe application.\n        \"major\" - The major version number of the CANoe application.\n        \"minor\" - The minor version number of the CANoe application.\n        \"patch\" - The patch number of the CANoe application.\n\n    Examples:\n        &gt;&gt;&gt; # The following example returns CANoe application version relevant information.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_version_info = canoe_inst.get_canoe_version_info()\n        &gt;&gt;&gt; print(canoe_version_info)\n    \"\"\"\n    ver_obj = Version(self.app)\n    version_info = {'full_name': ver_obj.full_name,\n                    'name': ver_obj.name,\n                    'build': ver_obj.build,\n                    'major': ver_obj.major,\n                    'minor': ver_obj.minor,\n                    'patch': ver_obj.patch}\n    self.log.info('&gt; CANoe Application.Version &lt;'.center(100, '='))\n    for k, v in version_info.items():\n        self.log.info(f'{k:&lt;10}: {v}')\n    self.log.info(''.center(100, '='))\n    return version_info\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_j1939_signal_full_name","title":"<code>get_j1939_signal_full_name(bus, channel, message, signal, source_addr, dest_addr)</code>","text":"<p>Determines the fully qualified name of a signal.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully qualified name of a signal. The following format will be used for signals: :::: Source code in <code>src\\py_canoe.py</code> <pre><code>def get_j1939_signal_full_name(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int) -&gt; str:\n\"\"\"Determines the fully qualified name of a signal.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n\n    Returns:\n        str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n    return sig_obj.full_name\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_j1939_signal_value","title":"<code>get_j1939_signal_value(bus, channel, message, signal, source_addr, dest_addr, raw_value=False)</code>","text":"<p>get_j1939_signal Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[float, int]</code> <p>signal vaue.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example gets j1939 signal value\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; sig_val = canoe_inst.get_j1939_signal_value('CAN', 1, 'LightState', 'FlashLight', 0, 1)\n&gt;&gt;&gt; print(sig_val)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int,\n                           raw_value=False) -&gt; Union[float, int]:\nr\"\"\"get_j1939_signal Returns a Signal object.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Returns:\n        signal vaue.\n\n    Examples:\n        &gt;&gt;&gt; # The following example gets j1939 signal value\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; sig_val = canoe_inst.get_j1939_signal_value('CAN', 1, 'LightState', 'FlashLight', 0, 1)\n        &gt;&gt;&gt; print(sig_val)\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n    signal_value = sig_obj.raw_value if raw_value else sig_obj.value\n    self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n    return signal_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_measurement_index","title":"<code>get_measurement_index()</code>","text":"<p>gets the measurement index for the next measurement.</p> <p>Returns:</p> Type Description <code>int</code> <p>Measurement Index.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example gets the measurement index measurement\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n&gt;&gt;&gt; canoe_inst.get_measurement_index()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_measurement_index(self) -&gt; int:\nr\"\"\"gets the measurement index for the next measurement.\n\n    Returns:\n        Measurement Index.\n\n    Examples:\n        &gt;&gt;&gt; # The following example gets the measurement index measurement\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n        &gt;&gt;&gt; canoe_inst.get_measurement_index()\n    \"\"\"\n    self.log.info(f'measurement_index value = {self.meas.measurement_index}')\n    return self.meas.measurement_index\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_measurement_running_status","title":"<code>get_measurement_running_status()</code>","text":"<p>Returns the running state of the measurement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if The measurement is running.</p> <code>bool</code> <p>False if The measurement is not running.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example returns measurement running status (True/False)\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.get_measurement_running_status()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_measurement_running_status(self) -&gt; bool:\nr\"\"\"Returns the running state of the measurement.\n\n    Returns:\n        True if The measurement is running.\n        False if The measurement is not running.\n\n    Examples:\n        &gt;&gt;&gt; # The following example returns measurement running status (True/False)\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.get_measurement_running_status()\n    \"\"\"\n    self.log.info(f'CANoe Measurement Running Status = {self.meas.running}')\n    return self.meas.running\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_signal_full_name","title":"<code>get_signal_full_name(bus, channel, message, signal)</code>","text":"<p>Determines the fully qualified name of a signal.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully qualified name of a signal. The following format will be used for signals: :::: Source code in <code>src\\py_canoe.py</code> <pre><code>def get_signal_full_name(self, bus: str, channel: int, message: str, signal: str) -&gt; str:\n\"\"\"Determines the fully qualified name of a signal.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        str: The fully qualified name of a signal. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n    return sig_obj.full_name\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_signal_value","title":"<code>get_signal_value(bus, channel, message, signal, raw_value=False)</code>","text":"<p>get_signal_value Returns a Signal value.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[float, int]</code> <p>signal vaue.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example gets signal value\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; sig_val = canoe_inst.get_signal_value('CAN', 1, 'LightState', 'FlashLight')\n&gt;&gt;&gt; print(sig_val)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_signal_value(self, bus: str, channel: int, message: str, signal: str, raw_value=False) -&gt; Union[float, int]:\nr\"\"\"get_signal_value Returns a Signal value.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Returns:\n        signal vaue.\n\n    Examples:\n        &gt;&gt;&gt; # The following example gets signal value\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; sig_val = canoe_inst.get_signal_value('CAN', 1, 'LightState', 'FlashLight')\n        &gt;&gt;&gt; print(sig_val)\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n    signal_value = sig_obj.raw_value if raw_value else sig_obj.value\n    self.log.info(f'value of signal({bus}{channel}.{message}.{signal})={signal_value}.')\n    return signal_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.get_system_variable_value","title":"<code>get_system_variable_value(sys_var_name)</code>","text":"<p>get_system_variable_value Returns a system variable value.</p> <p>Parameters:</p> Name Type Description Default <code>sys_var_name</code> <code>str</code> <p>The name of the system variable. Ex- \"sys_var_demo::speed\"</p> required <p>Returns:</p> Type Description <code>Union[int, float, str, None]</code> <p>System Variable value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example gets system variable value\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; sys_var_val = canoe_inst.get_system_variable_value('sys_var_demo::speed')\n&gt;&gt;&gt;print(sys_var_val)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def get_system_variable_value(self, sys_var_name: str) -&gt; Union[int, float, str, None]:\nr\"\"\"get_system_variable_value Returns a system variable value.\n\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n\n    Returns:\n        System Variable value.\n\n    Examples:\n        &gt;&gt;&gt; # The following example gets system variable value\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; sys_var_val = canoe_inst.get_system_variable_value('sys_var_demo::speed')\n        &gt;&gt;&gt;print(sys_var_val)\n    \"\"\"\n    namespace = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    return_value = None\n    try:\n        sys_obj = System(self.app)\n        namespace_object = sys_obj.sys_com_obj.Namespaces(namespace)\n        return_value = namespace_object.Variables(variable_name).Value\n        self.log.info(f'system variable({sys_var_name}) value = {return_value}.')\n    except Exception as e:\n        self.log.info(f'failed to get system variable({sys_var_name}) value. {e}')\n    return return_value\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.new","title":"<code>new(auto_save=False, prompt_user=False)</code>","text":"<p>Creates a new configuration.</p> <p>Parameters:</p> Name Type Description Default <code>auto_save</code> <code>bool</code> <p>A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.</p> <code>False</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations. Defaults to False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example creates a new configuration\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.new()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def new(self, auto_save=False, prompt_user=False) -&gt; None:\n\"\"\"Creates a new configuration.\n\n    Args:\n        auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n\n    Examples:\n        &gt;&gt;&gt; # The following example creates a new configuration\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.new()\n    \"\"\"\n    self.app.new(auto_save, prompt_user)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.open","title":"<code>open(canoe_cfg, visible=True, auto_save=False, prompt_user=False)</code>","text":"<p>Loads CANoe configuration.</p> <p>Parameters:</p> Name Type Description Default <code>canoe_cfg</code> <code>str</code> <p>The complete path for the CANoe configuration.</p> required <code>visible</code> <code>bool</code> <p>True if you want to see CANoe UI. Defaults to True.</p> <code>True</code> <code>auto_save</code> <code>bool</code> <p>A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.</p> <code>False</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations. Defaults to False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example opens a configuration\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def open(self, canoe_cfg: str, visible=True, auto_save=False, prompt_user=False) -&gt; None:\nr\"\"\"Loads CANoe configuration.\n\n    Args:\n        canoe_cfg (str): The complete path for the CANoe configuration.\n        visible (bool): True if you want to see CANoe UI. Defaults to True.\n        auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n\n    Examples:\n        &gt;&gt;&gt; # The following example opens a configuration\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n    \"\"\"\n    pythoncom.CoInitialize()\n    self.app.app_com_obj = win32com.client.Dispatch('CANoe.Application')\n    cav = self.app.app_com_obj.Version\n    self.log.info(f'Dispatched Vector CANoe Application {cav.major}.{cav.minor}.{cav.Build}')\n    self.app.app_com_obj.Configuration.Modified = False\n    self.app.visible = visible\n    self.app.open(path=canoe_cfg, auto_save=auto_save, prompt_user=prompt_user)\n    self.meas = Measurement(self.app, self.user_capl_function_names)\n    networks_obj = Networks(self.app)\n    self.__diag_devices = networks_obj.fetch_diag_devices()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.quit","title":"<code>quit()</code>","text":"<p>Quits CANoe without saving changes in the configuration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example quits CANoe\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.quit()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def quit(self):\nr\"\"\"Quits CANoe without saving changes in the configuration.\n\n    Examples:\n        &gt;&gt;&gt; # The following example quits CANoe\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.quit()\n    \"\"\"\n    self.app.quit()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.read_text_from_write_window","title":"<code>read_text_from_write_window()</code>","text":"<p>read the text contents from Write Window.</p> <p>Returns:</p> Type Description <code>str</code> <p>The text content.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example reads text from Write Window.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; print(canoe_inst.read_text_from_write_window())\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def read_text_from_write_window(self) -&gt; str:\nr\"\"\"read the text contents from Write Window.\n\n    Returns:\n        The text content.\n\n    Examples:\n        &gt;&gt;&gt; # The following example reads text from Write Window.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; print(canoe_inst.read_text_from_write_window())\n    \"\"\"\n    ui_obj = Ui(self.app)\n    return ui_obj.get_write_window_text_content()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.reset_measurement","title":"<code>reset_measurement()</code>","text":"<p>reset the measurement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Measurement running status(True/False).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example resets the measurement\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.reset_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def reset_measurement(self) -&gt; bool:\nr\"\"\"reset the measurement.\n\n    Returns:\n        Measurement running status(True/False).\n\n    Examples:\n        &gt;&gt;&gt; # The following example resets the measurement\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.reset_measurement()\n    \"\"\"\n    if self.meas.running:\n        self.meas.stop()\n    self.meas.start()\n    self.log.info(f'Resetted measurement.')\n    return self.meas.running\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.reset_measurement_in_offline_mode","title":"<code>reset_measurement_in_offline_mode()</code>","text":"<p>Resets the measurement in Offline mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example resets the measurement in Offline mode\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.reset_measurement_in_offline_mode()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def reset_measurement_in_offline_mode(self) -&gt; None:\nr\"\"\"Resets the measurement in Offline mode.\n\n    Examples:\n        &gt;&gt;&gt; # The following example resets the measurement in Offline mode\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.reset_measurement_in_offline_mode()\n    \"\"\"\n    self.meas.reset_offline_mode()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.save_configuration","title":"<code>save_configuration()</code>","text":"<p>Saves the configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration saved. else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example saves the configuration if necessary\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.save_configuration()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def save_configuration(self) -&gt; bool:\nr\"\"\"Saves the configuration.\n\n    Returns:\n        True if configuration saved. else False.\n\n    Examples:\n        &gt;&gt;&gt; # The following example saves the configuration if necessary\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.save_configuration()\n    \"\"\"\n    conf_obj = Configuration(self.app)\n    return conf_obj.save()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.save_configuration_as","title":"<code>save_configuration_as(path, major, minor, create_dir=True)</code>","text":"<p>Saves the configuration as a different CANoe version.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The complete file name.</p> required <code>major</code> <code>int</code> <p>The major version number of the target version.</p> required <code>minor</code> <code>int</code> <p>The minor version number of the target version.</p> required <code>create_dir</code> <code>bool</code> <p>create dirrectory if not available. default value True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration saved. else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example saves the configuration as a CANoe 10.0 version\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.save_configuration_as(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo_v12.cfg', 10, 0)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def save_configuration_as(self, path: str, major: int, minor: int, create_dir=True) -&gt; bool:\nr\"\"\"Saves the configuration as a different CANoe version.\n\n    Args:\n        path (str): The complete file name.\n        major (int): The major version number of the target version.\n        minor (int): The minor version number of the target version.\n        create_dir (bool): create dirrectory if not available. default value True.\n\n    Returns:\n        True if configuration saved. else False.\n\n    Examples:\n        &gt;&gt;&gt; # The following example saves the configuration as a CANoe 10.0 version\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.save_configuration_as(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo_v12.cfg', 10, 0)\"\"\"\n    conf_obj = Configuration(self.app)\n    config_path = '\\\\'.join(path.split('\\\\')[:-1])\n    if not os.path.exists(config_path) and create_dir:\n        os.makedirs(config_path, exist_ok=True)\n    if os.path.exists(config_path):\n        conf_obj.save_as(path, major, minor, False)\n        return conf_obj.saved\n    else:\n        self.log.info(f'tried creating {path}. but {config_path} directory not found.')\n        return False\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.send_diag_request","title":"<code>send_diag_request(diag_ecu_qualifier_name, request, request_in_bytes=True)</code>","text":"<p>The send_diag_request method represents the query of a diagnostic tester (client) to an ECU (server) in CANoe.</p> <p>Parameters:</p> Name Type Description Default <code>diag_ecu_qualifier_name</code> <code>str</code> <p>Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".</p> required <code>request</code> <code>str</code> <p>Diagnostic request in bytes or diagnostic node qualifier name.</p> required <code>request_in_bytes</code> <code>bool</code> <p>True if Diagnostic request is bytes. False if you are using Qualifier name. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>diagnostic response stream. Ex- \"50 01 00 00 00 00\"</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example 1 - The following example sends diagnostic request \"10 01\"\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; resp = canoe_inst.send_diag_request('Door', '10 01')\n&gt;&gt;&gt; print(resp)\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n&gt;&gt;&gt; # Example 2 - The following example sends diagnostic request \"DefaultSession_Start\"\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(canoe_cfg=r'C:\\Users\\Public\\Documents\\Vector\\CANoe\\Sample Configurations 11.0.81\\.\\CAN\\Diagnostics\\UDSBasic\\UDSBasic.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; resp = canoe_inst.send_diag_request('Door', 'DefaultSession_Start', False)\n&gt;&gt;&gt; print(resp)\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def send_diag_request(self, diag_ecu_qualifier_name: str, request: str, request_in_bytes=True) -&gt; str:\nr\"\"\"The send_diag_request method represents the query of a diagnostic tester (client) to an ECU (server) in CANoe.\n\n    Args:\n        diag_ecu_qualifier_name (str): Diagnostic Node ECU Qualifier Name configured in \"Diagnostic/ISO TP Configuration\".\n        request (str): Diagnostic request in bytes or diagnostic node qualifier name.\n        request_in_bytes (bool): True if Diagnostic request is bytes. False if you are using Qualifier name. Default is True.\n\n    Returns:\n        diagnostic response stream. Ex- \"50 01 00 00 00 00\"\n\n    Examples:\n        &gt;&gt;&gt; # Example 1 - The following example sends diagnostic request \"10 01\"\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; resp = canoe_inst.send_diag_request('Door', '10 01')\n        &gt;&gt;&gt; print(resp)\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n        &gt;&gt;&gt; # Example 2 - The following example sends diagnostic request \"DefaultSession_Start\"\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(canoe_cfg=r'C:\\Users\\Public\\Documents\\Vector\\CANoe\\Sample Configurations 11.0.81\\.\\CAN\\Diagnostics\\UDSBasic\\UDSBasic.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; resp = canoe_inst.send_diag_request('Door', 'DefaultSession_Start', False)\n        &gt;&gt;&gt; print(resp)\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n    \"\"\"\n    diag_response_data = \"\"\n    try:\n        if diag_ecu_qualifier_name in self.__diag_devices.keys():\n            self.log.info(f'Diag Req --&gt; {request}')\n            if request_in_bytes:\n                diag_req_in_bytes = bytearray()\n                request = ''.join(request.split(' '))\n                for i in range(0, len(request), 2):\n                    diag_req_in_bytes.append(int(request[i:i + 2], 16))\n                diag_req = self.__diag_devices[diag_ecu_qualifier_name].CreateRequestFromStream(diag_req_in_bytes)\n            else:\n                diag_req = self.__diag_devices[diag_ecu_qualifier_name].CreateRequest(request)\n            diag_req.Send()\n            while diag_req.Pending:\n                wait(0.1)\n            if diag_req.Responses.Count == 0:\n                self.log.info(\"Diagnostic Response Not Received.\")\n            else:\n                for k in range(1, diag_req.Responses.Count + 1):\n                    diag_res = diag_req.Responses(k)\n                    if diag_res.Positive:\n                        self.log.info(f\"+ve response received.\")\n                    else:\n                        self.log.info(f\"-ve response received.\")\n                    diag_response_data = \" \".join(f\"{d:02X}\" for d in diag_res.Stream).upper()\n                self.log.info(f'Diag Res --&gt; {diag_response_data}')\n        else:\n            self.log.info(f'Diag ECU qualifier({diag_ecu_qualifier_name}) not available in loaded CANoe config.')\n    except Exception as e:\n        self.log.info(f'failed to send diag request({request}). {e}')\n    return diag_response_data\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_j1939_signal_value","title":"<code>set_j1939_signal_value(bus, channel, message, signal, source_addr, dest_addr, value, raw_value=False)</code>","text":"<p>get_j1939_signal Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_addr</code> <code>int</code> <p>The source address of the ECU that sends the message.</p> required <code>dest_addr</code> <code>int</code> <p>The destination address of the ECU that receives the message.</p> required <code>value</code> <code>Union[float, int]</code> <p>signal value.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>signal vaue.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example gets j1939 signal value\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.set_j1939_signal_value('CAN', 1, 'LightState', 'FlashLight', 0, 1, 1)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_j1939_signal_value(self, bus: str, channel: int, message: str, signal: str, source_addr: int, dest_addr: int, value: Union[float, int],\n                           raw_value=False) -&gt; None:\nr\"\"\"get_j1939_signal Returns a Signal object.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_addr (int): The source address of the ECU that sends the message.\n        dest_addr (int): The destination address of the ECU that receives the message.\n        value (Union[float, int]): signal value.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Returns:\n        signal vaue.\n\n    Examples:\n        &gt;&gt;&gt; # The following example gets j1939 signal value\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.set_j1939_signal_value('CAN', 1, 'LightState', 'FlashLight', 0, 1, 1)\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_j1939_signal(channel, message, signal, source_addr, dest_addr))\n    if raw_value:\n        sig_obj.raw_value = value\n    else:\n        sig_obj.value = value\n    self.log.info(f'signal value set to {value}.')\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_measurement_index","title":"<code>set_measurement_index(index)</code>","text":"<p>sets the measurement index for the next measurement.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index value to set.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Measurement Index value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example sets the measurement index for the next measurement to 15\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n&gt;&gt;&gt; canoe_inst.set_measurement_index(15)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_measurement_index(self, index: int) -&gt; int:\nr\"\"\"sets the measurement index for the next measurement.\n\n    Args:\n        index (int): index value to set.\n\n    Returns:\n        Measurement Index value.\n\n    Examples:\n        &gt;&gt;&gt; # The following example sets the measurement index for the next measurement to 15\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n        &gt;&gt;&gt; canoe_inst.set_measurement_index(15)\n    \"\"\"\n    self.meas.measurement_index = index\n    return self.meas.measurement_index\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_replay_block_file","title":"<code>set_replay_block_file(block_name, recording_file_path)</code>","text":"<p>Method for setting CANoe replay block file.</p> <p>Parameters:</p> Name Type Description Default <code>block_name</code> <code>str</code> <p>CANoe replay block name</p> required <code>recording_file_path</code> <code>str</code> <p>CANoe replay recording file including path.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example sets replay block file\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.set_replay_block_file(block_name='replay block name', recording_file_path='replay file including path')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_replay_block_file(self, block_name: str, recording_file_path: str) -&gt; None:\nr\"\"\"Method for setting CANoe replay block file.\n\n    Args:\n        block_name: CANoe replay block name\n        recording_file_path: CANoe replay recording file including path.\n\n    Examples:\n        &gt;&gt;&gt; # The following example sets replay block file\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.set_replay_block_file(block_name='replay block name', recording_file_path='replay file including path')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n    \"\"\"\n    replay_blocks = self.__fetch_replay_blocks()\n    if block_name in replay_blocks.keys():\n        replay_blocks[block_name].Path = recording_file_path\n        self.log.info(f'Replay block \"{block_name}\" updated with \"{recording_file_path}\" path.')\n    else:\n        self.log.warning(f'Replay block \"{block_name}\" not available.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_signal_value","title":"<code>set_signal_value(bus, channel, message, signal, value, raw_value=False)</code>","text":"<p>set_signal_value sets a value to Signal. Works only when messages are sent using CANoe IL.</p> <p>Parameters:</p> Name Type Description Default <code>bus</code> <code>str</code> <p>The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.</p> required <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>value</code> <code>Union[float, int]</code> <p>signal value.</p> required <code>raw_value</code> <code>bool</code> <p>return raw value of the signal if true. Default(False) is physical value.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example sets signal value to 1\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.set_signal_value('CAN', 1, 'LightState', 'FlashLight', 1)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_signal_value(self, bus: str, channel: int, message: str, signal: str, value: int, raw_value=False) -&gt; None:\nr\"\"\"set_signal_value sets a value to Signal. Works only when messages are sent using CANoe IL.\n\n    Args:\n        bus (str): The Bus(CAN, LIN, FlexRay, MOST, AFDX, Ethernet) on which the signal is sent.\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        value (Union[float, int]): signal value.\n        raw_value (bool): return raw value of the signal if true. Default(False) is physical value.\n\n    Examples:\n        &gt;&gt;&gt; # The following example sets signal value to 1\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.set_signal_value('CAN', 1, 'LightState', 'FlashLight', 1)\n    \"\"\"\n    bus_obj = Bus(self.app, bus_type=bus)\n    sig_obj = Signal(bus_obj.get_signal(channel, message, signal))\n    if raw_value:\n        sig_obj.raw_value = value\n    else:\n        sig_obj.value = value\n    self.log.info(f'signal({bus}{channel}.{message}.{signal}) value set to {value}.')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.set_system_variable_value","title":"<code>set_system_variable_value(sys_var_name, value)</code>","text":"<p>set_system_variable_value sets a value to system variable.</p> <p>Parameters:</p> Name Type Description Default <code>sys_var_name</code> <code>str</code> <p>The name of the system variable. Ex- \"sys_var_demo::speed\"</p> required <code>value</code> <code>Union[int, float, str]</code> <p>variable value.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example sets system variable value to 1\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.set_system_variable_value('sys_var_demo::speed', 1)\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def set_system_variable_value(self, sys_var_name: str, value: Union[int, float, str]) -&gt; None:\nr\"\"\"set_system_variable_value sets a value to system variable.\n\n    Args:\n        sys_var_name (str): The name of the system variable. Ex- \"sys_var_demo::speed\"\n        value (Union[int, float, str]): variable value.\n\n    Examples:\n        &gt;&gt;&gt; # The following example sets system variable value to 1\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.set_system_variable_value('sys_var_demo::speed', 1)\n    \"\"\"\n    namespace = '::'.join(sys_var_name.split('::')[:-1])\n    variable_name = sys_var_name.split('::')[-1]\n    try:\n        sys_obj = System(self.app)\n        namespace_object = sys_obj.sys_com_obj.Namespaces(namespace)\n        namespace_object.Variables(variable_name).Value = value\n        self.log.info(f'system variable({sys_var_name}) value set to {value}.')\n    except Exception as e:\n        self.log.info(f'failed to set system variable({sys_var_name}) value. {e}')\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.start_measurement","title":"<code>start_measurement()</code>","text":"<p>Starts the measurement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if measurement started. else Flase.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example starts the measurement\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def start_measurement(self) -&gt; bool:\nr\"\"\"Starts the measurement.\n\n    Returns:\n        True if measurement started. else Flase.\n\n    Examples:\n        &gt;&gt;&gt; # The following example starts the measurement\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n    \"\"\"\n    return self.meas.start()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.start_measurement_in_animation_mode","title":"<code>start_measurement_in_animation_mode(animation_delay=100)</code>","text":"<p>Starts the measurement in Animation mode.</p> <p>Parameters:</p> Name Type Description Default <code>animation_delay</code> <code>int</code> <p>The animation delay during the measurement in Offline Mode.</p> <code>100</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example starts the measurement in Animation mode\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement_in_animation_mode()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def start_measurement_in_animation_mode(self, animation_delay=100) -&gt; None:\nr\"\"\"Starts the measurement in Animation mode.\n\n    Args:\n        animation_delay (int): The animation delay during the measurement in Offline Mode.\n\n    Examples:\n        &gt;&gt;&gt; # The following example starts the measurement in Animation mode\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement_in_animation_mode()\n    \"\"\"\n    self.meas.animation_delay = animation_delay\n    self.meas.animate()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.step_measurement_event_in_single_step","title":"<code>step_measurement_event_in_single_step()</code>","text":"<p>Processes a measurement event in single step.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example processes a measurement event in single step\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.step_measurement_event_in_single_step()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def step_measurement_event_in_single_step(self) -&gt; None:\nr\"\"\"Processes a measurement event in single step.\n\n    Examples:\n        &gt;&gt;&gt; # The following example processes a measurement event in single step\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.step_measurement_event_in_single_step()\n    \"\"\"\n    self.meas.step()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_ex_measurement","title":"<code>stop_ex_measurement()</code>","text":"<p>StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if measurement stopped. else Flase.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example full stops the measurement\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.stop_ex_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_ex_measurement(self) -&gt; bool:\nr\"\"\"StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.\n\n    Returns:\n        True if measurement stopped. else Flase.\n\n    Examples:\n        &gt;&gt;&gt; # The following example full stops the measurement\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.stop_ex_measurement()\n    \"\"\"\n    return self.meas.stop_ex()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.stop_measurement","title":"<code>stop_measurement()</code>","text":"<p>Stops the measurement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if measurement stopped. else Flase.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example stops the measurement\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def stop_measurement(self) -&gt; bool:\nr\"\"\"Stops the measurement.\n\n    Returns:\n        True if measurement stopped. else Flase.\n\n    Examples:\n        &gt;&gt;&gt; # The following example stops the measurement\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n    \"\"\"\n    return self.meas.stop()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.ui_activate_desktop","title":"<code>ui_activate_desktop(name)</code>","text":"<p>Activates the desktop with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the desktop to be activated.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example switches to the desktop with the name \"Configuration\"\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; canoe_inst.ui_activate_desktop(\"Configuration\")\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def ui_activate_desktop(self, name: str) -&gt; None:\nr\"\"\"Activates the desktop with the given name.\n\n    Args:\n        name (str): The name of the desktop to be activated.\n\n    Examples:\n        &gt;&gt;&gt; # The following example switches to the desktop with the name \"Configuration\"\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; canoe_inst.ui_activate_desktop(\"Configuration\")\n    \"\"\"\n    ui_obj = Ui(self.app)\n    ui_obj.activate_desktop(name)\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.ui_open_baudrate_dialog","title":"<code>ui_open_baudrate_dialog()</code>","text":"<p>opens the dialog for configuring the bus parameters. Make sure Measurement stopped when using this method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example opens the dialog for configuring the bus parameters\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.stop_measurement()\n&gt;&gt;&gt; canoe_inst.ui_open_baudrate_dialog()\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def ui_open_baudrate_dialog(self) -&gt; None:\nr\"\"\"opens the dialog for configuring the bus parameters. Make sure Measurement stopped when using this method.\n\n    Examples:\n        &gt;&gt;&gt; # The following example opens the dialog for configuring the bus parameters\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.stop_measurement()\n        &gt;&gt;&gt; canoe_inst.ui_open_baudrate_dialog()\n    \"\"\"\n    ui_obj = Ui(self.app)\n    ui_obj.open_baudrate_dialog()\n</code></pre>"},{"location":"999_reference/#src.py_canoe.CANoe.write_text_in_write_window","title":"<code>write_text_in_write_window(text)</code>","text":"<p>Outputs a line of text in the Write Window. Args:     text (str): The text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # The following example Outputs a line of text in the Write Window.\n&gt;&gt;&gt; canoe_inst = CANoe()\n&gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n&gt;&gt;&gt; canoe_inst.start_measurement()\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n&gt;&gt;&gt; wait(1)\n&gt;&gt;&gt; print(canoe_inst.read_text_from_write_window())\n</code></pre> Source code in <code>src\\py_canoe.py</code> <pre><code>def write_text_in_write_window(self, text: str) -&gt; None:\nr\"\"\"Outputs a line of text in the Write Window.\n    Args:\n        text (str): The text.\n\n    Examples:\n        &gt;&gt;&gt; # The following example Outputs a line of text in the Write Window.\n        &gt;&gt;&gt; canoe_inst = CANoe()\n        &gt;&gt;&gt; canoe_inst.open(r'D:\\_kms_local\\vector_canoe\\py_canoe\\demo_cfg\\demo.cfg')\n        &gt;&gt;&gt; canoe_inst.start_measurement()\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; canoe_inst.write_text_in_write_window(\"hello from python!\")\n        &gt;&gt;&gt; wait(1)\n        &gt;&gt;&gt; print(canoe_inst.read_text_from_write_window())\n    \"\"\"\n    ui_obj = Ui(self.app)\n    ui_obj.send_text_to_write_window(text)\n</code></pre>"},{"location":"999_reference/#src.utils.application.Application","title":"<code>Application</code>","text":"<p>The Application object represents the CANoe application.</p> Source code in <code>src\\utils\\application.py</code> <pre><code>class Application:\n\"\"\"The Application object represents the CANoe application.\n    \"\"\"\n    OPENED = False\n    CLOSED = False\n\n    def __init__(self, log_obj) -&gt; None:\n        self.app_com_obj = None\n        self.log = log_obj\n\n    @property\n    def channel_mapping_name(self) -&gt; str:\n\"\"\"get the application name which is used to map application channels to real existing Vector hardware interface channels.\n\n        Returns:\n            str: The application name\n        \"\"\"\n        return self.app_com_obj.ChannelMappingName\n\n    @channel_mapping_name.setter\n    def channel_mapping_name(self, name: str):\n\"\"\"set the application name which is used to map application channels to real existing Vector hardware interface channels.\n\n        Args:\n            name (str): The application name used to map the channels.\n        \"\"\"\n        self.app_com_obj.ChannelMappingName = name\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"determines the complete path of the CANoe application.\n\n        Returns:\n            str: location where CANoe is installed.\n        \"\"\"\n        return self.app_com_obj.FullName\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the name of the CANoe application.\n\n        Returns:\n            str: name of the CANoe application.\n        \"\"\"\n        return self.app_com_obj.Name\n\n    @property\n    def path(self) -&gt; str:\n\"\"\"Returns the Path of the CANoe application.\n\n        Returns:\n            str: Path of the CANoe application.\n        \"\"\"\n        return self.app_com_obj.Path\n\n    @property\n    def visible(self) -&gt; bool:\n\"\"\"Returns whether the CANoe main window is visible or is only displayed by a tray icon.\n\n        Returns:\n            bool: A boolean value indicating whether the CANoe main window is visible..\n        \"\"\"\n        return self.app_com_obj.Visible\n\n    @visible.setter\n    def visible(self, visible: bool):\n\"\"\"Defines whether the CANoe main window is visible or is only displayed by a tray icon.\n\n        Args:\n            visible (bool): A boolean value indicating whether the CANoe main window is to be visible.\n        \"\"\"\n        self.app_com_obj.Visible = visible\n\n    def new(self, auto_save=False, prompt_user=False) -&gt; None:\n\"\"\"Creates a new configuration.\n\n        Args:\n            auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n        \"\"\"\n        self.app_com_obj.New(auto_save, prompt_user)\n        self.log.info('created a new configuration...')\n\n    def open(self, path: str, auto_save=False, prompt_user=False) -&gt; None:\n\"\"\"Loads a configuration.\n\n        Args:\n            path (str): The complete path for the configuration.\n            auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n\n        Raises:\n            FileNotFoundError: _description_\n        \"\"\"\n        if os.path.isfile(path):\n            self.log.info(f'CANoe cfg \"{path}\" found.')\n            self.app_com_obj.Open(path, auto_save, prompt_user)\n            self.log.info(f'loaded CANoe config \"{path}\"')\n        else:\n            self.log.info(f'CANoe cfg \"{path}\" not found.')\n            raise FileNotFoundError(f'CANoe cfg file \"{path}\" not found!')\n\n    def quit(self):\n\"\"\"Quits the application.\n        \"\"\"\n        self.app_com_obj.Quit()\n        self.log.info('CANoe Application Closed.')\n</code></pre>"},{"location":"999_reference/#src.utils.application.Application.channel_mapping_name","title":"<code>channel_mapping_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>get the application name which is used to map application channels to real existing Vector hardware interface channels.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The application name</p>"},{"location":"999_reference/#src.utils.application.Application.full_name","title":"<code>full_name: str</code>  <code>property</code>","text":"<p>determines the complete path of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>location where CANoe is installed.</p>"},{"location":"999_reference/#src.utils.application.Application.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>name of the CANoe application.</p>"},{"location":"999_reference/#src.utils.application.Application.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>Returns the Path of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path of the CANoe application.</p>"},{"location":"999_reference/#src.utils.application.Application.visible","title":"<code>visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns whether the CANoe main window is visible or is only displayed by a tray icon.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>A boolean value indicating whether the CANoe main window is visible..</p>"},{"location":"999_reference/#src.utils.application.Application.new","title":"<code>new(auto_save=False, prompt_user=False)</code>","text":"<p>Creates a new configuration.</p> <p>Parameters:</p> Name Type Description Default <code>auto_save</code> <code>bool</code> <p>A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.</p> <code>False</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations. Defaults to False.</p> <code>False</code> Source code in <code>src\\utils\\application.py</code> <pre><code>def new(self, auto_save=False, prompt_user=False) -&gt; None:\n\"\"\"Creates a new configuration.\n\n    Args:\n        auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n    \"\"\"\n    self.app_com_obj.New(auto_save, prompt_user)\n    self.log.info('created a new configuration...')\n</code></pre>"},{"location":"999_reference/#src.utils.application.Application.open","title":"<code>open(path, auto_save=False, prompt_user=False)</code>","text":"<p>Loads a configuration.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The complete path for the configuration.</p> required <code>auto_save</code> <code>bool</code> <p>A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.</p> <code>False</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>description</p> Source code in <code>src\\utils\\application.py</code> <pre><code>def open(self, path: str, auto_save=False, prompt_user=False) -&gt; None:\n\"\"\"Loads a configuration.\n\n    Args:\n        path (str): The complete path for the configuration.\n        auto_save (bool, optional): A boolean value that indicates whether the active configuration should be saved if it has been changed. Defaults to False.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations. Defaults to False.\n\n    Raises:\n        FileNotFoundError: _description_\n    \"\"\"\n    if os.path.isfile(path):\n        self.log.info(f'CANoe cfg \"{path}\" found.')\n        self.app_com_obj.Open(path, auto_save, prompt_user)\n        self.log.info(f'loaded CANoe config \"{path}\"')\n    else:\n        self.log.info(f'CANoe cfg \"{path}\" not found.')\n        raise FileNotFoundError(f'CANoe cfg file \"{path}\" not found!')\n</code></pre>"},{"location":"999_reference/#src.utils.application.Application.quit","title":"<code>quit()</code>","text":"<p>Quits the application.</p> Source code in <code>src\\utils\\application.py</code> <pre><code>def quit(self):\n\"\"\"Quits the application.\n    \"\"\"\n    self.app_com_obj.Quit()\n    self.log.info('CANoe Application Closed.')\n</code></pre>"},{"location":"999_reference/#src.utils.application.ApplicationEvents","title":"<code>ApplicationEvents</code>","text":"<p>Handler for CANoe Application events</p> Source code in <code>src\\utils\\application.py</code> <pre><code>class ApplicationEvents:\n\"\"\"Handler for CANoe Application events\"\"\"\n\n    @staticmethod\n    def OnOpen():\n\"\"\"Occurs when a configuration is opened.\n        \"\"\"\n        print('canoe opened')\n        Application.OPENED = True\n        Application.CLOSED = False\n\n    @staticmethod\n    def OnQuit():\n\"\"\"Occurs when CANoe is quit\n        \"\"\"\n        print('canoe closed')\n        Application.OPENED = False\n        Application.CLOSED = True\n</code></pre>"},{"location":"999_reference/#src.utils.application.ApplicationEvents.OnOpen","title":"<code>OnOpen()</code>  <code>staticmethod</code>","text":"<p>Occurs when a configuration is opened.</p> Source code in <code>src\\utils\\application.py</code> <pre><code>@staticmethod\ndef OnOpen():\n\"\"\"Occurs when a configuration is opened.\n    \"\"\"\n    print('canoe opened')\n    Application.OPENED = True\n    Application.CLOSED = False\n</code></pre>"},{"location":"999_reference/#src.utils.application.ApplicationEvents.OnQuit","title":"<code>OnQuit()</code>  <code>staticmethod</code>","text":"<p>Occurs when CANoe is quit</p> Source code in <code>src\\utils\\application.py</code> <pre><code>@staticmethod\ndef OnQuit():\n\"\"\"Occurs when CANoe is quit\n    \"\"\"\n    print('canoe closed')\n    Application.OPENED = False\n    Application.CLOSED = True\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Bus","title":"<code>Bus</code>","text":"<p>The Bus object represents a bus of the CANoe application.</p> Source code in <code>src\\utils\\bus.py</code> <pre><code>class Bus:\n\"\"\"The Bus object represents a bus of the CANoe application.\n    \"\"\"\n    def __init__(self, app_obj, bus_type='CAN') -&gt; None:\n\"\"\"Returns a Signal object.\n\n        Args:\n            app_obj (object): application class instance object.\n            bus_type (str, optional): The desired bus type. Valid types are: CAN, LIN, FlexRay, AFDX, Ethernet. Defaults to 'CAN'.\n        \"\"\"\n        self.app_obj = app_obj\n        self.log = self.app_obj.log\n        self.bus_com_obj = self.app_obj.app_com_obj.GetBus(bus_type)\n\n    @property\n    def active(self) -&gt; bool:\n\"\"\"determines the status of the Bus object.\n\n        Returns:\n            bool: The status of the Bus object.\n        \"\"\"\n        return self.bus_com_obj.Active\n\n    @active.setter\n    def active(self, value: bool) -&gt; None:\n\"\"\"Sets the status of the Bus object.\n\n        Args:\n            value (bool): A boolean value that indicates whether the bus is to be simulated: TRUE: The bus will be simulated. FALSE: The bus will not be simulated.\n        \"\"\"\n        self.bus_com_obj.Active = value\n        self.log.info(f'status of the Bus object set to {value}.')\n\n    @property\n    def baudrate(self, channel_number: int) -&gt; int:\n\"\"\"Determines the baud rate of a channel.\n\n        Args:\n            channel_number (int): The channel number.\n\n        Returns:\n            int: The current baud rate of the channel.\n        \"\"\"\n        return self.bus_com_obj.Baudrate(channel_number)\n\n    @property\n    def bus_name(self) -&gt; str:\n\"\"\"returns the bus name.\n\n        Returns:\n            str: The bus name.\n        \"\"\"\n        return self.bus_com_obj.Name\n\n    def set_bus_name(self, name: str) -&gt; None:\n\"\"\"Sets the bus name\n\n        Args:\n            name (str): The new name.\n        \"\"\"\n        self.bus_com_obj.Name = name\n        self.log.info(f'bus name set to {name}.')\n\n    def get_signal(self, channel: int, message: str, signal: str) -&gt; object:\n\"\"\"Returns a Signal object.\n\n        Args:\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n\n        Returns:\n            object: The Signal object.\n        \"\"\"\n        return self.bus_com_obj.GetSignal(channel, message, signal)\n\n    def get_j1939_signal(self, channel: int, message: str, signal: str, source_address: int, destination_address: int) -&gt; object:\n\"\"\"Returns a Signal object.\n\n        Args:\n            channel (int): The channel on which the signal is sent.\n            message (str): The name of the message to which the signal belongs.\n            signal (str): The name of the signal.\n            source_address (int): The source address of the ECU that sends the message\n            destination_address (int): The destination address of the ECU that receives the message. For signals of global Parameter Groups (PDU 2 format) this parameter is not considered.\n\n        Returns:\n            object: The Signal object.\n        \"\"\"\n        return self.bus_com_obj.GetJ1939Signal(channel, message, signal, source_address, destination_address)\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Bus.active","title":"<code>active: bool</code>  <code>property</code> <code>writable</code>","text":"<p>determines the status of the Bus object.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The status of the Bus object.</p>"},{"location":"999_reference/#src.utils.bus.Bus.baudrate","title":"<code>baudrate: int</code>  <code>property</code>","text":"<p>Determines the baud rate of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_number</code> <code>int</code> <p>The channel number.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current baud rate of the channel.</p>"},{"location":"999_reference/#src.utils.bus.Bus.bus_name","title":"<code>bus_name: str</code>  <code>property</code>","text":"<p>returns the bus name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The bus name.</p>"},{"location":"999_reference/#src.utils.bus.Bus.__init__","title":"<code>__init__(app_obj, bus_type='CAN')</code>","text":"<p>Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>app_obj</code> <code>object</code> <p>application class instance object.</p> required <code>bus_type</code> <code>str</code> <p>The desired bus type. Valid types are: CAN, LIN, FlexRay, AFDX, Ethernet. Defaults to 'CAN'.</p> <code>'CAN'</code> Source code in <code>src\\utils\\bus.py</code> <pre><code>def __init__(self, app_obj, bus_type='CAN') -&gt; None:\n\"\"\"Returns a Signal object.\n\n    Args:\n        app_obj (object): application class instance object.\n        bus_type (str, optional): The desired bus type. Valid types are: CAN, LIN, FlexRay, AFDX, Ethernet. Defaults to 'CAN'.\n    \"\"\"\n    self.app_obj = app_obj\n    self.log = self.app_obj.log\n    self.bus_com_obj = self.app_obj.app_com_obj.GetBus(bus_type)\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Bus.get_j1939_signal","title":"<code>get_j1939_signal(channel, message, signal, source_address, destination_address)</code>","text":"<p>Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <code>source_address</code> <code>int</code> <p>The source address of the ECU that sends the message</p> required <code>destination_address</code> <code>int</code> <p>The destination address of the ECU that receives the message. For signals of global Parameter Groups (PDU 2 format) this parameter is not considered.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The Signal object.</p> Source code in <code>src\\utils\\bus.py</code> <pre><code>def get_j1939_signal(self, channel: int, message: str, signal: str, source_address: int, destination_address: int) -&gt; object:\n\"\"\"Returns a Signal object.\n\n    Args:\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n        source_address (int): The source address of the ECU that sends the message\n        destination_address (int): The destination address of the ECU that receives the message. For signals of global Parameter Groups (PDU 2 format) this parameter is not considered.\n\n    Returns:\n        object: The Signal object.\n    \"\"\"\n    return self.bus_com_obj.GetJ1939Signal(channel, message, signal, source_address, destination_address)\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Bus.get_signal","title":"<code>get_signal(channel, message, signal)</code>","text":"<p>Returns a Signal object.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>The channel on which the signal is sent.</p> required <code>message</code> <code>str</code> <p>The name of the message to which the signal belongs.</p> required <code>signal</code> <code>str</code> <p>The name of the signal.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The Signal object.</p> Source code in <code>src\\utils\\bus.py</code> <pre><code>def get_signal(self, channel: int, message: str, signal: str) -&gt; object:\n\"\"\"Returns a Signal object.\n\n    Args:\n        channel (int): The channel on which the signal is sent.\n        message (str): The name of the message to which the signal belongs.\n        signal (str): The name of the signal.\n\n    Returns:\n        object: The Signal object.\n    \"\"\"\n    return self.bus_com_obj.GetSignal(channel, message, signal)\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Bus.set_bus_name","title":"<code>set_bus_name(name)</code>","text":"<p>Sets the bus name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required Source code in <code>src\\utils\\bus.py</code> <pre><code>def set_bus_name(self, name: str) -&gt; None:\n\"\"\"Sets the bus name\n\n    Args:\n        name (str): The new name.\n    \"\"\"\n    self.bus_com_obj.Name = name\n    self.log.info(f'bus name set to {name}.')\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Signal","title":"<code>Signal</code>","text":"<p>The Signal object represents a signal on the bus.</p> Source code in <code>src\\utils\\bus.py</code> <pre><code>class Signal:\n\"\"\"The Signal object represents a signal on the bus.\n    \"\"\"\n    def __init__(self, signal_com_object) -&gt; None:\n        self.sig_com_obj = signal_com_object\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"Determines the fully qualified name of a signal.\n\n        Returns:\n            str: The fully qualified name of a signal or a message. The following format will be used for signals: &lt;DatabaseName&gt;::&lt;MessageName&gt;::&lt;SignalName&gt;\n        \"\"\"\n        return self.sig_com_obj.FullName\n\n    @property\n    def is_online(self) -&gt; bool:\n\"\"\"Checks whether the measurement is running and the signal has been received.\n\n        Returns:\n            bool: TRUE: if the measurement is running and the signal has been received. FALSE: if not.\n        \"\"\"\n        return self.sig_com_obj.IsOnline\n\n    @property\n    def raw_value(self) -&gt; int:\n\"\"\"Returns the current value of the signal as it was transmitted on the bus.\n\n        Returns:\n            int: The raw value of the signal.\n        \"\"\"\n        return self.sig_com_obj.RawValue\n\n    @raw_value.setter\n    def raw_value(self, value: int) -&gt; None:\n\"\"\"Returns the current value of the signal as it was transmitted on the bus.\n\n        Returns:\n            int: The raw value of the signal.\n        \"\"\"\n        self.sig_com_obj.RawValue = value\n\n    @property\n    def state(self) -&gt; int:\n\"\"\"Returns the state of the signal.\n\n        Returns:\n            int: State of the signal; possible values are: 0: The default value of the signal is returned. 1: The measurement is not running; the value set by the application is returned. 3: The signal has been received in the current measurement; the current value is returned.\n        \"\"\"\n        return self.sig_com_obj.State\n\n    @property\n    def value(self) -&gt; int:\n\"\"\"gets the active value of the signal.\n\n\n        Returns:\n            int: The value of the signal\n        \"\"\"\n        return self.sig_com_obj.Value\n\n    @value.setter\n    def value(self, value: int) -&gt; None:\n\"\"\"sets the active value of the signal.\n\n        Args:\n            value (int): The new value of the signal.\n        \"\"\"\n        self.sig_com_obj.Value = value\n</code></pre>"},{"location":"999_reference/#src.utils.bus.Signal.full_name","title":"<code>full_name: str</code>  <code>property</code>","text":"<p>Determines the fully qualified name of a signal.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully qualified name of a signal or a message. The following format will be used for signals: ::::"},{"location":"999_reference/#src.utils.bus.Signal.is_online","title":"<code>is_online: bool</code>  <code>property</code>","text":"<p>Checks whether the measurement is running and the signal has been received.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>TRUE: if the measurement is running and the signal has been received. FALSE: if not.</p>"},{"location":"999_reference/#src.utils.bus.Signal.raw_value","title":"<code>raw_value: int</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the current value of the signal as it was transmitted on the bus.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The raw value of the signal.</p>"},{"location":"999_reference/#src.utils.bus.Signal.state","title":"<code>state: int</code>  <code>property</code>","text":"<p>Returns the state of the signal.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>State of the signal; possible values are: 0: The default value of the signal is returned. 1: The measurement is not running; the value set by the application is returned. 3: The signal has been received in the current measurement; the current value is returned.</p>"},{"location":"999_reference/#src.utils.bus.Signal.value","title":"<code>value: int</code>  <code>property</code> <code>writable</code>","text":"<p>gets the active value of the signal.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value of the signal</p>"},{"location":"999_reference/#src.utils.capl.Capl","title":"<code>Capl</code>","text":"<p>The CAPL object allows to compile all nodes (CAPL, .NET, XML) in the configuration. Additionally it represents the CAPL functions available in the CAPL programs. Please note that only user-defined CAPL functions can be accessed</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>class Capl:\n\"\"\"The CAPL object allows to compile all nodes (CAPL, .NET, XML) in the configuration.\n    Additionally it represents the CAPL functions available in the CAPL programs.\n    Please note that only user-defined CAPL functions can be accessed\n    \"\"\"\n    def __init__(self, app_obj: object) -&gt; None:\n        self.app_obj = app_obj\n        self.log = self.app_obj.log\n        self.capl_obj = win32com.client.Dispatch(self.app_obj.app_com_obj.CAPL)\n\n    def compile(self) -&gt; None:\n\"\"\"Translates all CAPL, XML and .NET nodes.\n        \"\"\"\n        self.capl_obj.Compile()\n\n    def get_function(self, name: str) -&gt; object:\n\"\"\"Returns a CAPLFunction object.\n\n        Args:\n            name (str): The name of the CAPL function.\n\n        Returns:\n            object: The CAPLFunction object.\n        \"\"\"\n        return self.capl_obj.GetFunction(name)\n\n    @staticmethod\n    def parameter_count(capl_function_object: object) -&gt; int:\n\"\"\"Returns the number of parameters of the CAPL function.\n\n        Args:\n            capl_function_object (object): The CAPLFunction object.\n\n        Returns:\n            int: The number of parameters of the CAPL function.\n        \"\"\"\n        return capl_function_object.ParameterCount\n\n\n    @staticmethod\n    def parameter_types(capl_function_object: object) -&gt; tuple:\n\"\"\"Returns the types of the parameters of the CAPL function as byte array.\n        The parameter types are coded as follows:\n        L: long (32 bit signed integer)\n        D: dword (32 bit unsigned integer)\n        F: double (64 bit floating point)\n\n        Args:\n            capl_function_object (object): The CAPLFunction object.\n\n        Returns:\n            tuple: The types of the parameters of the CAPL function as byte array.\n        \"\"\"\n        return capl_function_object.ParameterTypes\n\n    def call_capl_function(self, capl_function_obj: object, *arguments) -&gt; bool:\n\"\"\"Calls a CAPL function.\n        Please note that the number of parameters must agree with that of the CAPL function.\n        The return value is only available for CAPL functions whose CAPL programs are configured in the Measurement Setup.\n        Only integers are allowed as a return type.\n\n        Args:\n            capl_function_obj (str): CAPL function object.\n            arguments (tuple): Function parameters p1\u2026p10 (optional).\n\n        Returns:\n            bool: CAPL function execution status. True-success, False-failed.\n        \"\"\"\n        return_value = False\n        if len(arguments) == self.parameter_count(capl_function_obj):\n            if len(arguments) &gt; 0:\n                capl_function_obj.Call(*arguments)\n            else:\n                capl_function_obj.Call()\n            return_value = True\n        else:\n            print(fr'function arguments not matching with CAPL user function args.')\n        return return_value\n\n    def compile_result(self) -&gt; dict:\n\"\"\"The CompileResult object represents the result of the last compilation of the CAPL object.\n\n        Returns:\n            dict: returns dictionary of 'error_message', 'node_name', 'result', 'source_file'\n        \"\"\"\n        return_values = dict()\n        compile_result_obj = self.capl_obj.CompileResult\n        # Returns the last compilation error for the CompileResult object or the last loading error/warning for the OpenConfigurationResult object\n        return_values['error_message'] = compile_result_obj.ErrorMessage\n        # Returns the name of the first compilation error node.\n        return_values['node_name'] = compile_result_obj.NodeName\n        # Returns the result of the last compilation of the CAPL object.\n        return_values['result'] = compile_result_obj.Result\n        # Returns the path of the program file where the first compile error occurred\n        return_values['source_file'] = compile_result_obj.SourceFile\n        return return_values\n</code></pre>"},{"location":"999_reference/#src.utils.capl.Capl.call_capl_function","title":"<code>call_capl_function(capl_function_obj, *arguments)</code>","text":"<p>Calls a CAPL function. Please note that the number of parameters must agree with that of the CAPL function. The return value is only available for CAPL functions whose CAPL programs are configured in the Measurement Setup. Only integers are allowed as a return type.</p> <p>Parameters:</p> Name Type Description Default <code>capl_function_obj</code> <code>str</code> <p>CAPL function object.</p> required <code>arguments</code> <code>tuple</code> <p>Function parameters p1\u2026p10 (optional).</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>CAPL function execution status. True-success, False-failed.</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>def call_capl_function(self, capl_function_obj: object, *arguments) -&gt; bool:\n\"\"\"Calls a CAPL function.\n    Please note that the number of parameters must agree with that of the CAPL function.\n    The return value is only available for CAPL functions whose CAPL programs are configured in the Measurement Setup.\n    Only integers are allowed as a return type.\n\n    Args:\n        capl_function_obj (str): CAPL function object.\n        arguments (tuple): Function parameters p1\u2026p10 (optional).\n\n    Returns:\n        bool: CAPL function execution status. True-success, False-failed.\n    \"\"\"\n    return_value = False\n    if len(arguments) == self.parameter_count(capl_function_obj):\n        if len(arguments) &gt; 0:\n            capl_function_obj.Call(*arguments)\n        else:\n            capl_function_obj.Call()\n        return_value = True\n    else:\n        print(fr'function arguments not matching with CAPL user function args.')\n    return return_value\n</code></pre>"},{"location":"999_reference/#src.utils.capl.Capl.compile","title":"<code>compile()</code>","text":"<p>Translates all CAPL, XML and .NET nodes.</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>def compile(self) -&gt; None:\n\"\"\"Translates all CAPL, XML and .NET nodes.\n    \"\"\"\n    self.capl_obj.Compile()\n</code></pre>"},{"location":"999_reference/#src.utils.capl.Capl.compile_result","title":"<code>compile_result()</code>","text":"<p>The CompileResult object represents the result of the last compilation of the CAPL object.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>returns dictionary of 'error_message', 'node_name', 'result', 'source_file'</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>def compile_result(self) -&gt; dict:\n\"\"\"The CompileResult object represents the result of the last compilation of the CAPL object.\n\n    Returns:\n        dict: returns dictionary of 'error_message', 'node_name', 'result', 'source_file'\n    \"\"\"\n    return_values = dict()\n    compile_result_obj = self.capl_obj.CompileResult\n    # Returns the last compilation error for the CompileResult object or the last loading error/warning for the OpenConfigurationResult object\n    return_values['error_message'] = compile_result_obj.ErrorMessage\n    # Returns the name of the first compilation error node.\n    return_values['node_name'] = compile_result_obj.NodeName\n    # Returns the result of the last compilation of the CAPL object.\n    return_values['result'] = compile_result_obj.Result\n    # Returns the path of the program file where the first compile error occurred\n    return_values['source_file'] = compile_result_obj.SourceFile\n    return return_values\n</code></pre>"},{"location":"999_reference/#src.utils.capl.Capl.get_function","title":"<code>get_function(name)</code>","text":"<p>Returns a CAPLFunction object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the CAPL function.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The CAPLFunction object.</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>def get_function(self, name: str) -&gt; object:\n\"\"\"Returns a CAPLFunction object.\n\n    Args:\n        name (str): The name of the CAPL function.\n\n    Returns:\n        object: The CAPLFunction object.\n    \"\"\"\n    return self.capl_obj.GetFunction(name)\n</code></pre>"},{"location":"999_reference/#src.utils.capl.Capl.parameter_count","title":"<code>parameter_count(capl_function_object)</code>  <code>staticmethod</code>","text":"<p>Returns the number of parameters of the CAPL function.</p> <p>Parameters:</p> Name Type Description Default <code>capl_function_object</code> <code>object</code> <p>The CAPLFunction object.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of parameters of the CAPL function.</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>@staticmethod\ndef parameter_count(capl_function_object: object) -&gt; int:\n\"\"\"Returns the number of parameters of the CAPL function.\n\n    Args:\n        capl_function_object (object): The CAPLFunction object.\n\n    Returns:\n        int: The number of parameters of the CAPL function.\n    \"\"\"\n    return capl_function_object.ParameterCount\n</code></pre>"},{"location":"999_reference/#src.utils.capl.Capl.parameter_types","title":"<code>parameter_types(capl_function_object)</code>  <code>staticmethod</code>","text":"<p>Returns the types of the parameters of the CAPL function as byte array. The parameter types are coded as follows: L: long (32 bit signed integer) D: dword (32 bit unsigned integer) F: double (64 bit floating point)</p> <p>Parameters:</p> Name Type Description Default <code>capl_function_object</code> <code>object</code> <p>The CAPLFunction object.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>The types of the parameters of the CAPL function as byte array.</p> Source code in <code>src\\utils\\capl.py</code> <pre><code>@staticmethod\ndef parameter_types(capl_function_object: object) -&gt; tuple:\n\"\"\"Returns the types of the parameters of the CAPL function as byte array.\n    The parameter types are coded as follows:\n    L: long (32 bit signed integer)\n    D: dword (32 bit unsigned integer)\n    F: double (64 bit floating point)\n\n    Args:\n        capl_function_object (object): The CAPLFunction object.\n\n    Returns:\n        tuple: The types of the parameters of the CAPL function as byte array.\n    \"\"\"\n    return capl_function_object.ParameterTypes\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.CanoeConfigurationEvents","title":"<code>CanoeConfigurationEvents</code>","text":"<p>Handler for CANoe Configuration events</p> Source code in <code>src\\utils\\configuration.py</code> <pre><code>class CanoeConfigurationEvents:\n\"\"\"Handler for CANoe Configuration events\"\"\"\n\n    @staticmethod\n    def OnClose():\n\"\"\"Occurs when the configuration is closed.\n        \"\"\"\n        print('configuration OnClose event triggered.')\n\n    @staticmethod\n    def OnSystemVariablesDefinitionChanged():\n\"\"\"Occurs when system variable definitions are added, changed or removed.\n        \"\"\"\n        print('configuration OnSystemVariablesDefinitionChanged event triggered.')\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.CanoeConfigurationEvents.OnClose","title":"<code>OnClose()</code>  <code>staticmethod</code>","text":"<p>Occurs when the configuration is closed.</p> Source code in <code>src\\utils\\configuration.py</code> <pre><code>@staticmethod\ndef OnClose():\n\"\"\"Occurs when the configuration is closed.\n    \"\"\"\n    print('configuration OnClose event triggered.')\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.CanoeConfigurationEvents.OnSystemVariablesDefinitionChanged","title":"<code>OnSystemVariablesDefinitionChanged()</code>  <code>staticmethod</code>","text":"<p>Occurs when system variable definitions are added, changed or removed.</p> Source code in <code>src\\utils\\configuration.py</code> <pre><code>@staticmethod\ndef OnSystemVariablesDefinitionChanged():\n\"\"\"Occurs when system variable definitions are added, changed or removed.\n    \"\"\"\n    print('configuration OnSystemVariablesDefinitionChanged event triggered.')\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>The Configuration object represents the active configuration.</p> Source code in <code>src\\utils\\configuration.py</code> <pre><code>class Configuration:\n\"\"\"The Configuration object represents the active configuration.\n    \"\"\"\n    def __init__(self, app_obj) -&gt; None:\n        self.app_obj = app_obj\n        self.log = self.app_obj.log\n        self.conf_com_obj = win32com.client.Dispatch(self.app_obj.app_com_obj.Configuration)\n        win32com.client.WithEvents(self.conf_com_obj, CanoeConfigurationEvents)\n\n    @property\n    def comment(self) -&gt; str:\n\"\"\"Gets the comment for the configuration.\n\n        Returns:\n            str: The comment.\n        \"\"\"\n        return self.conf_com_obj.Comment\n\n    @comment.setter\n    def comment(self, text: str) -&gt; None:\n\"\"\"Defines the comment for the configuration.\n\n        Args:\n            text (str): The comment.\n        \"\"\"\n        self.conf_com_obj.Comment = text\n        self.log.info(f'configuration comment set to {text}.')\n\n    @property\n    def fdx_enabled(self) -&gt; int:\n\"\"\"Enables/Disables value of FDX protocol.\n\n        Returns:\n            int: The activation state of the FDX protocol. 0: FDX protocol is deactivated. 1: FDX protocol is activated.\n        \"\"\"\n        return self.conf_com_obj.FDXEnabled\n\n    @fdx_enabled.setter\n    def fdx_enabled(self, enabled: int) -&gt; None:\n\"\"\"Enables/Disables the FDX protocol.\n\n        Args:\n            enabled (int): The activation state of the FDX protocol. 0: deactivate FDX protocol. \u22600: activate FDX protocol.\n        \"\"\"\n        self.conf_com_obj.FDXEnabled = enabled\n        self.log.info(f'FDX protocol set to {enabled}.')\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"gets the complete path of the configuration.\n\n        Returns:\n            str: complete path of the configuration.\n        \"\"\"\n        return self.conf_com_obj.FullName\n\n    @full_name.setter\n    def full_name(self, full_name: str) -&gt; None:\n\"\"\"sets the complete path of the configuration.\n\n        Args:\n            full_name (str): The new complete path of the configuration.\n        \"\"\"\n        self.conf_com_obj.FullName = full_name\n        self.log.info(f'complete path of the configuration set to {full_name}.')\n\n    @property\n    def mode(self) -&gt; int:\n\"\"\"returns whether the Online mode or the Offline mode is active.\n\n        Returns:\n            int: The currently active mode.\n        \"\"\"\n        return self.conf_com_obj.Mode\n\n    @mode.setter\n    def mode(self, mode: int) -&gt; None:\n\"\"\"sets the Online mode or the Offline mode to active.\n\n        Args:\n            mode (int): The active mode; valid values are: 0-Online mode is activated. 1-Offline mode is activated.\n        \"\"\"\n        self.conf_com_obj.Mode = mode\n        self.log.info(f'offline/online mode set to {mode}.')\n\n    @property\n    def modified(self) -&gt; bool:\n\"\"\"Returns information on whether the current configuration was modified since the time it was loaded or created, or sets this property.\n        This property determines whether the user is prompted to save when another configuration is loaded.\n\n        Returns:\n            bool: The current value of the property.\n        \"\"\"\n        return self.conf_com_obj.Modified\n\n    @modified.setter\n    def modified(self, modified: bool) -&gt; None:\n\"\"\"sets Modified property to flase/true.\n\n        Args:\n            modified (bool): Value to be assigned to the Modified property.\n        \"\"\"\n        self.conf_com_obj.Modified = modified\n        self.log.info(f'configuration modified property set to {modified}.')\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the name of the configuration.\n\n        Returns:\n            str: The name of the currently loaded configuration.\n        \"\"\"\n        return self.conf_com_obj.Name\n\n    @property\n    def path(self) -&gt; str:\n\"\"\"returns the path of the configuration, depending on the actual configuration.\n\n        Returns:\n            str: The path of the currently loaded configuration.\n        \"\"\"\n        return self.conf_com_obj.Path\n\n    @property\n    def read_only(self) -&gt; bool:\n\"\"\"Indicates whether the configuration is write protected.\n\n        Returns:\n            bool: If the object is write protected True is returned; otherwise False is returned.\n        \"\"\"\n        return self.conf_com_obj.ReadOnly\n\n    @property\n    def saved(self) -&gt; bool:\n\"\"\"Indicates whether changes to the configuration have already been saved.\n\n        Returns:\n            bool: If changes were made to the configuration and they have not been saved yet, False is returned; otherwise True is returned.\n        \"\"\"\n        return self.conf_com_obj.Saved\n\n    def compile_and_verify(self):\n\"\"\"Compiles all CAPL test modules and verifies all XML test modules.\n        All test modules in the Simulation Setup and in the Test Setup are taken into consideration.\n        \"\"\"\n        self.conf_com_obj.CompileAndVerify()\n        self.log.info(f'Compiled all test modules in the Simulation Setup and in the Test Setup.')\n\n    def save(self, path='', prompt_user=False):\n\"\"\"Saves the configuration.\n\n        Args:\n            path (str): The complete file name. If no path is specified, the configuration is saved under its current name. If it is not saved yet, the user will be prompted for a name.\n            prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations.\n        \"\"\"\n        if not self.saved:\n            if path == '':\n                self.conf_com_obj.Save()\n            else:\n                self.conf_com_obj.Save(path, prompt_user)\n            self.log.info(f'Saved configuration({path}).')\n        else:\n            self.log.info('CANoe Configuration already in saved state.')\n        return self.saved\n\n    def save_as(self, path: str, major: str, minor: str, prompt_user: bool):\n\"\"\"Saves the configuration as a different CANoe version\n\n        Args:\n            path (str): The complete path.\n            major (str): The major version number of the target version, e.g. 10 for CANoe 10.1.\n            minor (str): The minor version number of the target version, e.g. 1 for CANoe 10.1\n            prompt_user (bool): A boolean value that defines whether the user should interact in error situations.\n        \"\"\"\n        self.conf_com_obj.SaveAs(path, major, minor, prompt_user)\n        self.log.info(f'Saved configuration as {path}.')\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.Configuration.comment","title":"<code>comment: str</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the comment for the configuration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The comment.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.fdx_enabled","title":"<code>fdx_enabled: int</code>  <code>property</code> <code>writable</code>","text":"<p>Enables/Disables value of FDX protocol.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The activation state of the FDX protocol. 0: FDX protocol is deactivated. 1: FDX protocol is activated.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.full_name","title":"<code>full_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>gets the complete path of the configuration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>complete path of the configuration.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.mode","title":"<code>mode: int</code>  <code>property</code> <code>writable</code>","text":"<p>returns whether the Online mode or the Offline mode is active.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The currently active mode.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.modified","title":"<code>modified: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Returns information on whether the current configuration was modified since the time it was loaded or created, or sets this property. This property determines whether the user is prompted to save when another configuration is loaded.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The current value of the property.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the configuration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the currently loaded configuration.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.path","title":"<code>path: str</code>  <code>property</code>","text":"<p>returns the path of the configuration, depending on the actual configuration.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path of the currently loaded configuration.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.read_only","title":"<code>read_only: bool</code>  <code>property</code>","text":"<p>Indicates whether the configuration is write protected.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the object is write protected True is returned; otherwise False is returned.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.saved","title":"<code>saved: bool</code>  <code>property</code>","text":"<p>Indicates whether changes to the configuration have already been saved.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If changes were made to the configuration and they have not been saved yet, False is returned; otherwise True is returned.</p>"},{"location":"999_reference/#src.utils.configuration.Configuration.compile_and_verify","title":"<code>compile_and_verify()</code>","text":"<p>Compiles all CAPL test modules and verifies all XML test modules. All test modules in the Simulation Setup and in the Test Setup are taken into consideration.</p> Source code in <code>src\\utils\\configuration.py</code> <pre><code>def compile_and_verify(self):\n\"\"\"Compiles all CAPL test modules and verifies all XML test modules.\n    All test modules in the Simulation Setup and in the Test Setup are taken into consideration.\n    \"\"\"\n    self.conf_com_obj.CompileAndVerify()\n    self.log.info(f'Compiled all test modules in the Simulation Setup and in the Test Setup.')\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.Configuration.save","title":"<code>save(path='', prompt_user=False)</code>","text":"<p>Saves the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The complete file name. If no path is specified, the configuration is saved under its current name. If it is not saved yet, the user will be prompted for a name.</p> <code>''</code> <code>prompt_user</code> <code>bool</code> <p>A boolean value that indicates whether the user should intervene in error situations.</p> <code>False</code> Source code in <code>src\\utils\\configuration.py</code> <pre><code>def save(self, path='', prompt_user=False):\n\"\"\"Saves the configuration.\n\n    Args:\n        path (str): The complete file name. If no path is specified, the configuration is saved under its current name. If it is not saved yet, the user will be prompted for a name.\n        prompt_user (bool, optional): A boolean value that indicates whether the user should intervene in error situations.\n    \"\"\"\n    if not self.saved:\n        if path == '':\n            self.conf_com_obj.Save()\n        else:\n            self.conf_com_obj.Save(path, prompt_user)\n        self.log.info(f'Saved configuration({path}).')\n    else:\n        self.log.info('CANoe Configuration already in saved state.')\n    return self.saved\n</code></pre>"},{"location":"999_reference/#src.utils.configuration.Configuration.save_as","title":"<code>save_as(path, major, minor, prompt_user)</code>","text":"<p>Saves the configuration as a different CANoe version</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The complete path.</p> required <code>major</code> <code>str</code> <p>The major version number of the target version, e.g. 10 for CANoe 10.1.</p> required <code>minor</code> <code>str</code> <p>The minor version number of the target version, e.g. 1 for CANoe 10.1</p> required <code>prompt_user</code> <code>bool</code> <p>A boolean value that defines whether the user should interact in error situations.</p> required Source code in <code>src\\utils\\configuration.py</code> <pre><code>def save_as(self, path: str, major: str, minor: str, prompt_user: bool):\n\"\"\"Saves the configuration as a different CANoe version\n\n    Args:\n        path (str): The complete path.\n        major (str): The major version number of the target version, e.g. 10 for CANoe 10.1.\n        minor (str): The minor version number of the target version, e.g. 1 for CANoe 10.1\n        prompt_user (bool): A boolean value that defines whether the user should interact in error situations.\n    \"\"\"\n    self.conf_com_obj.SaveAs(path, major, minor, prompt_user)\n    self.log.info(f'Saved configuration as {path}.')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.CanoeMeasurementEvents","title":"<code>CanoeMeasurementEvents</code>","text":"<p>Handler for CANoe Measurement events</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>class CanoeMeasurementEvents:\n\"\"\"Handler for CANoe Measurement events\"\"\"\n    app_com_obj = object\n    user_capl_function_names = tuple()\n    user_capl_function_obj_dict = dict()\n\n    @staticmethod\n    def OnInit():\n\"\"\"Occurs when the measurement is initialized.\n        \"\"\"\n        app_com_obj_loc = CanoeMeasurementEvents.app_com_obj\n        for fun in CanoeMeasurementEvents.user_capl_function_names:\n            CanoeMeasurementEvents.user_capl_function_obj_dict[fun] = app_com_obj_loc.CAPL.GetFunction(fun)\n        print('measurement OnInit event triggered')\n\n    @staticmethod\n    def OnExit():\n\"\"\"Occurs when the measurement is exited.\n        \"\"\"\n        print('measurement OnExit event triggered')\n\n    @staticmethod\n    def OnStart():\n\"\"\"Occurs when the measurement is started.\n        \"\"\"\n        Measurement.STARTED = True\n        Measurement.STOPPED = False\n        print('measurement OnStart event triggered')\n\n    @staticmethod\n    def OnStop():\n\"\"\"Occurs when the measurement is stopped.\n        \"\"\"\n        Measurement.STARTED = False\n        Measurement.STOPPED = True\n        print('measurement OnStop event triggered')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.CanoeMeasurementEvents.OnExit","title":"<code>OnExit()</code>  <code>staticmethod</code>","text":"<p>Occurs when the measurement is exited.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>@staticmethod\ndef OnExit():\n\"\"\"Occurs when the measurement is exited.\n    \"\"\"\n    print('measurement OnExit event triggered')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.CanoeMeasurementEvents.OnInit","title":"<code>OnInit()</code>  <code>staticmethod</code>","text":"<p>Occurs when the measurement is initialized.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>@staticmethod\ndef OnInit():\n\"\"\"Occurs when the measurement is initialized.\n    \"\"\"\n    app_com_obj_loc = CanoeMeasurementEvents.app_com_obj\n    for fun in CanoeMeasurementEvents.user_capl_function_names:\n        CanoeMeasurementEvents.user_capl_function_obj_dict[fun] = app_com_obj_loc.CAPL.GetFunction(fun)\n    print('measurement OnInit event triggered')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.CanoeMeasurementEvents.OnStart","title":"<code>OnStart()</code>  <code>staticmethod</code>","text":"<p>Occurs when the measurement is started.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>@staticmethod\ndef OnStart():\n\"\"\"Occurs when the measurement is started.\n    \"\"\"\n    Measurement.STARTED = True\n    Measurement.STOPPED = False\n    print('measurement OnStart event triggered')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.CanoeMeasurementEvents.OnStop","title":"<code>OnStop()</code>  <code>staticmethod</code>","text":"<p>Occurs when the measurement is stopped.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>@staticmethod\ndef OnStop():\n\"\"\"Occurs when the measurement is stopped.\n    \"\"\"\n    Measurement.STARTED = False\n    Measurement.STOPPED = True\n    print('measurement OnStop event triggered')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement","title":"<code>Measurement</code>","text":"<p>The Measurement object represents measurement functions of CANoe.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>class Measurement:\n\"\"\"The Measurement object represents measurement functions of CANoe.\n    \"\"\"\n    STARTED = False\n    STOPPED = False\n\n    def __init__(self, app, user_capl_function_names=tuple()) -&gt; None:\n        self.app = app\n        self.log = self.app.log\n        CanoeMeasurementEvents.app_com_obj = self.app.app_com_obj\n        CanoeMeasurementEvents.user_capl_function_names = user_capl_function_names\n        self.meas_obj = win32com.client.Dispatch(self.app.app_com_obj.Measurement)\n        self.wait_for_canoe_meas_to_start = lambda: DoEventsUntil(lambda: Measurement.STARTED)\n        self.wait_for_canoe_meas_to_stop = lambda: DoEventsUntil(lambda: Measurement.STOPPED)\n        win32com.client.WithEvents(self.meas_obj, CanoeMeasurementEvents)\n\n    @property\n    def animation_delay(self) -&gt; int:\n\"\"\"Defines the animation delay during the measurement in Offline mode.\n\n        Returns:\n            int: The animation delay during the measurement in Offline mode.\n        \"\"\"\n        return self.meas_obj.AnimationDelay\n\n    @animation_delay.setter\n    def animation_delay(self, delay: int):\n\"\"\"Sets the animation delay during the measurement in Offline mode.\n\n        Args:\n            delay (int): Animation delay\n        \"\"\"\n        self.meas_obj.AnimationDelay = delay\n        self.log.info(f'Animation delay set to = {delay}.')\n\n    @property\n    def measurement_index(self) -&gt; int:\n\"\"\"Determines the measurement index for the next measurement.\n\n        Returns:\n            int: Returns the measurement index for the next measurement.\n        \"\"\"\n        return self.meas_obj.MeasurementIndex\n\n    @measurement_index.setter\n    def measurement_index(self, index: int):\n\"\"\"sets the measurement index for the next measurement.\n\n        Args:\n            index (int): The measurement index for the next measurement.\n        \"\"\"\n        self.meas_obj.MeasurementIndex = index\n        self.log.info(f'next measurement index set to = {index}.')\n\n    @property\n    def running(self) -&gt; bool:\n\"\"\"Returns the running state of the measurement.\n\n        Returns:\n            bool: True- The measurement is running. False- The measurement is not running.\n        \"\"\"\n        return self.meas_obj.Running\n\n    @property\n    def user_capl_function_obj_dict(self):\n        return CanoeMeasurementEvents.user_capl_function_obj_dict\n\n    def animate(self) -&gt; None:\n\"\"\"Starts the measurement in Animation mode.\n        \"\"\"\n        self.meas_obj.Animate()\n        self.log.info(f'Started the measurement in Animation mode with animation delay = {self.animation_delay}.')\n\n    def break_offline_mode(self) -&gt; None:\n\"\"\"Interrupts the playback in Offline mode.\n        \"\"\"\n        if self.running:\n            self.meas_obj.Break()\n            self.log.info('Interrupted the playback in Offline mode.')\n\n    def reset_offline_mode(self) -&gt; None:\n\"\"\"Resets the measurement in Offline mode.\n        \"\"\"\n        self.meas_obj.Reset()\n        self.log.info('resetted measurement in offline mode.')\n\n    def start(self) -&gt; None:\n\"\"\"Starts the measurement.\n        \"\"\"\n        if not self.running:\n            self.meas_obj.Start()\n            if not self.running:\n                self.log.info(f'waiting for measurement to start...')\n                self.wait_for_canoe_meas_to_start()\n            self.log.info(f'CANoe Measurement Started. Measurement running status = {self.running}')\n        else:\n            self.log.info(f'CANoe Measurement Already Running. Measurement running status = {self.running}')\n        return self.running\n\n    def step(self) -&gt; None:\n\"\"\"Processes a measurement event in single step.\n        \"\"\"\n        if not self.running:\n            self.meas_obj.Step()\n            self.log.info('processed a measurement event in single step')\n\n    def stop(self) -&gt; None:\n\"\"\"Stops the measurement.\n        \"\"\"\n        return self.stop_ex()\n\n    def stop_ex(self) -&gt; None:\n\"\"\"StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.\n        Calling the StopEx method correlates to clicking the Stop button.\n        \"\"\"\n        if self.running:\n            self.meas_obj.StopEx()\n            if self.running:\n                self.log.info(f'waiting for measurement to stop...')\n                self.wait_for_canoe_meas_to_stop()\n            self.log.info(f'CANoe Measurement Stopped. Measurement running status = {self.running}')\n        else:\n            self.log.info(f'CANoe Measurement Already Stopped. Measurement running status = {self.running}')\n        return not self.running\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.animation_delay","title":"<code>animation_delay: int</code>  <code>property</code> <code>writable</code>","text":"<p>Defines the animation delay during the measurement in Offline mode.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The animation delay during the measurement in Offline mode.</p>"},{"location":"999_reference/#src.utils.measurement.Measurement.measurement_index","title":"<code>measurement_index: int</code>  <code>property</code> <code>writable</code>","text":"<p>Determines the measurement index for the next measurement.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Returns the measurement index for the next measurement.</p>"},{"location":"999_reference/#src.utils.measurement.Measurement.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Returns the running state of the measurement.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True- The measurement is running. False- The measurement is not running.</p>"},{"location":"999_reference/#src.utils.measurement.Measurement.animate","title":"<code>animate()</code>","text":"<p>Starts the measurement in Animation mode.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def animate(self) -&gt; None:\n\"\"\"Starts the measurement in Animation mode.\n    \"\"\"\n    self.meas_obj.Animate()\n    self.log.info(f'Started the measurement in Animation mode with animation delay = {self.animation_delay}.')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.break_offline_mode","title":"<code>break_offline_mode()</code>","text":"<p>Interrupts the playback in Offline mode.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def break_offline_mode(self) -&gt; None:\n\"\"\"Interrupts the playback in Offline mode.\n    \"\"\"\n    if self.running:\n        self.meas_obj.Break()\n        self.log.info('Interrupted the playback in Offline mode.')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.reset_offline_mode","title":"<code>reset_offline_mode()</code>","text":"<p>Resets the measurement in Offline mode.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def reset_offline_mode(self) -&gt; None:\n\"\"\"Resets the measurement in Offline mode.\n    \"\"\"\n    self.meas_obj.Reset()\n    self.log.info('resetted measurement in offline mode.')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.start","title":"<code>start()</code>","text":"<p>Starts the measurement.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def start(self) -&gt; None:\n\"\"\"Starts the measurement.\n    \"\"\"\n    if not self.running:\n        self.meas_obj.Start()\n        if not self.running:\n            self.log.info(f'waiting for measurement to start...')\n            self.wait_for_canoe_meas_to_start()\n        self.log.info(f'CANoe Measurement Started. Measurement running status = {self.running}')\n    else:\n        self.log.info(f'CANoe Measurement Already Running. Measurement running status = {self.running}')\n    return self.running\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.step","title":"<code>step()</code>","text":"<p>Processes a measurement event in single step.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def step(self) -&gt; None:\n\"\"\"Processes a measurement event in single step.\n    \"\"\"\n    if not self.running:\n        self.meas_obj.Step()\n        self.log.info('processed a measurement event in single step')\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.stop","title":"<code>stop()</code>","text":"<p>Stops the measurement.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def stop(self) -&gt; None:\n\"\"\"Stops the measurement.\n    \"\"\"\n    return self.stop_ex()\n</code></pre>"},{"location":"999_reference/#src.utils.measurement.Measurement.stop_ex","title":"<code>stop_ex()</code>","text":"<p>StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe. Calling the StopEx method correlates to clicking the Stop button.</p> Source code in <code>src\\utils\\measurement.py</code> <pre><code>def stop_ex(self) -&gt; None:\n\"\"\"StopEx repairs differences in the behavior of the Stop method on deferred stops concerning simulated and real mode in CANoe.\n    Calling the StopEx method correlates to clicking the Stop button.\n    \"\"\"\n    if self.running:\n        self.meas_obj.StopEx()\n        if self.running:\n            self.log.info(f'waiting for measurement to stop...')\n            self.wait_for_canoe_meas_to_stop()\n        self.log.info(f'CANoe Measurement Stopped. Measurement running status = {self.running}')\n    else:\n        self.log.info(f'CANoe Measurement Already Stopped. Measurement running status = {self.running}')\n    return not self.running\n</code></pre>"},{"location":"999_reference/#src.utils.networks.Network","title":"<code>Network</code>","text":"Source code in <code>src\\utils\\networks.py</code> <pre><code>class Network:\n    def __init__(self, network_com_obj) -&gt; None:\n        self.network_com_obj = network_com_obj\n\n    @property\n    def bus_type(self) -&gt; int:\n\"\"\"Determines the bus type of the network\n\n        Returns:\n            int: The type of the network: 0-Invalid, 1-CAN, 2-J1939, 5-LIN, 6-MOST, 7-FlexRay, 9-J1708, 11-Ethernet\n        \"\"\"\n        return self.network_com_obj.BusType\n\n    @property\n    def devices(self) -&gt; object:\n\"\"\"Returns the Devices object.\n\n        Returns:\n            object: The Devices object\n        \"\"\"\n        return self.network_com_obj.Devices\n\n    @property\n    def name(self) -&gt; str:\n        return self.network_com_obj.Name\n</code></pre>"},{"location":"999_reference/#src.utils.networks.Network.bus_type","title":"<code>bus_type: int</code>  <code>property</code>","text":"<p>Determines the bus type of the network</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The type of the network: 0-Invalid, 1-CAN, 2-J1939, 5-LIN, 6-MOST, 7-FlexRay, 9-J1708, 11-Ethernet</p>"},{"location":"999_reference/#src.utils.networks.Network.devices","title":"<code>devices: object</code>  <code>property</code>","text":"<p>Returns the Devices object.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The Devices object</p>"},{"location":"999_reference/#src.utils.simulation.CanoeSimulationEvents","title":"<code>CanoeSimulationEvents</code>","text":"<p>Handler for CANoe Simulation events</p> Source code in <code>src\\utils\\simulation.py</code> <pre><code>class CanoeSimulationEvents:\n\"\"\"Handler for CANoe Simulation events\"\"\"\n\n    @staticmethod\n    def OnIdle(time_high: int, time: int) -&gt; None:\n\"\"\"Occurs after a simulation step.\n\n        Args:\n            time_high (int): High-order 32 bit of the current simulation time.\n            time (int): Low-order 32 bit of the current simulation time.\n        \"\"\"\n        print(f'Simulation OnIdle event triggered. time_high = {time_high} and time = {time}')\n\n    @staticmethod\n    def OnIdleU(time_high: int, time: int) -&gt; None:\n\"\"\"Occurs after a simulation step.\n\n        Args:\n            time_high (int): High-order 32 bit of the current simulation time.\n            time (int): Low-order 32 bit of the current simulation time.\n        \"\"\"\n        print(f'Simulation OnIdleU event triggered. time_high = {time_high} and time = {time}')\n</code></pre>"},{"location":"999_reference/#src.utils.simulation.CanoeSimulationEvents.OnIdle","title":"<code>OnIdle(time_high, time)</code>  <code>staticmethod</code>","text":"<p>Occurs after a simulation step.</p> <p>Parameters:</p> Name Type Description Default <code>time_high</code> <code>int</code> <p>High-order 32 bit of the current simulation time.</p> required <code>time</code> <code>int</code> <p>Low-order 32 bit of the current simulation time.</p> required Source code in <code>src\\utils\\simulation.py</code> <pre><code>@staticmethod\ndef OnIdle(time_high: int, time: int) -&gt; None:\n\"\"\"Occurs after a simulation step.\n\n    Args:\n        time_high (int): High-order 32 bit of the current simulation time.\n        time (int): Low-order 32 bit of the current simulation time.\n    \"\"\"\n    print(f'Simulation OnIdle event triggered. time_high = {time_high} and time = {time}')\n</code></pre>"},{"location":"999_reference/#src.utils.simulation.CanoeSimulationEvents.OnIdleU","title":"<code>OnIdleU(time_high, time)</code>  <code>staticmethod</code>","text":"<p>Occurs after a simulation step.</p> <p>Parameters:</p> Name Type Description Default <code>time_high</code> <code>int</code> <p>High-order 32 bit of the current simulation time.</p> required <code>time</code> <code>int</code> <p>Low-order 32 bit of the current simulation time.</p> required Source code in <code>src\\utils\\simulation.py</code> <pre><code>@staticmethod\ndef OnIdleU(time_high: int, time: int) -&gt; None:\n\"\"\"Occurs after a simulation step.\n\n    Args:\n        time_high (int): High-order 32 bit of the current simulation time.\n        time (int): Low-order 32 bit of the current simulation time.\n    \"\"\"\n    print(f'Simulation OnIdleU event triggered. time_high = {time_high} and time = {time}')\n</code></pre>"},{"location":"999_reference/#src.utils.simulation.Simulation","title":"<code>Simulation</code>","text":"<p>The Simulation object represents CANoe's measurement functions in the Simulation mode. With the help of the Simulation object you can control the system time from an external source during the measurement.</p> Source code in <code>src\\utils\\simulation.py</code> <pre><code>class Simulation:\n\"\"\"The Simulation object represents CANoe's measurement functions in the Simulation mode.\n    With the help of the Simulation object you can control the system time from an external source during the measurement.\n    \"\"\"\n    def __init__(self, app) -&gt; None:\n        self.app = app\n        self.log = self.app.log\n        self.sim_obj = win32com.client.Dispatch(self.app.app_com_obj.Simulation)\n        win32com.client.WithEvents(self.meas_obj, CanoeSimulationEvents)\n\n    @property\n    def animation(self) -&gt; int:\n\"\"\"Returns the animation factor.\n\n        Returns:\n            int: The animation factor.\n        \"\"\"\n        return self.sim_obj.Animation\n\n    @animation.setter\n    def animation(self, value: int) -&gt; None:\n\"\"\"Sets the animation factor.\n\n        Args:\n            value (int): The animation factor.\n        \"\"\"\n        self.sim_obj.Animation = value\n        self.log.info(f'animation factor set to = {value}.')\n\n    @property\n    def current_time(self) -&gt; int:\n\"\"\"Returns the low-order 32 bit of the current system time.\n\n        Returns:\n            int: The low-order 32 bit of the current system time.\n        \"\"\"\n        return self.sim_obj.CurrentTime\n\n    @property\n    def current_time_high(self) -&gt; int:\n\"\"\"Returns the high-order 32 bit of the current system time.\n\n        Returns:\n            int: The high-order 32 bit of the current system time.\n        \"\"\"\n        return self.sim_obj.CurrentTimeHigh\n\n    @property\n    def notification_type(self) -&gt; int:\n\"\"\"gets the notification type for the OnIdle handler.\n\n        Returns:\n            int: The notification type. 0-Idle. 1-IdleU\n        \"\"\"\n        return self.sim_obj.NotificationType\n\n    @notification_type.setter\n    def notification_type(self, value: int) -&gt; None:\n\"\"\"sets the notification type for the OnIdle handler.\n\n        Args:\n            value (int): The notification type. 0-Idle. 1-IdleU\n        \"\"\"\n        self.sim_obj.NotificationType = value\n        self.log.info(f'notification type set to = {value}.')\n\n    def increment_time(self, ticks: int) -&gt; None:\n\"\"\"Increases the system time during the measurement in simulation mode.\n        Whereas IncrementTime returns immediately after calling, the IncrementTimeAndWait function returns not until the simulation step is done in CANoe.\n\n        Args:\n            ticks (int): The number of ticks by which the system time is to be increased. 1 tick corresponds to 10 \u00b5s.\n        \"\"\"\n        self.sim_obj.IncrementTime(ticks)\n        self.log.info(f'Increased the system time to = {ticks} ticks.')\n\n    def increment_time_and_wait(self, ticks: int) -&gt; None:\n\"\"\"Increases the system time during the measurement in Simulation mode.\n        Whereas IncrementTime returns immediately after calling, the IncrementTimeAndWait method returns not until the simulation step is done in CANoe.\n\n        Args:\n            ticks (int): The number of ticks by which the system time is to be increased. 1 tick corresponds to 10 \u00b5s.\n        \"\"\"\n        self.sim_obj.IncrementTimeAndWait(ticks)\n        self.log.info(f'Increased the system time to = {ticks} ticks.')\n</code></pre>"},{"location":"999_reference/#src.utils.simulation.Simulation.animation","title":"<code>animation: int</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the animation factor.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The animation factor.</p>"},{"location":"999_reference/#src.utils.simulation.Simulation.current_time","title":"<code>current_time: int</code>  <code>property</code>","text":"<p>Returns the low-order 32 bit of the current system time.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The low-order 32 bit of the current system time.</p>"},{"location":"999_reference/#src.utils.simulation.Simulation.current_time_high","title":"<code>current_time_high: int</code>  <code>property</code>","text":"<p>Returns the high-order 32 bit of the current system time.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The high-order 32 bit of the current system time.</p>"},{"location":"999_reference/#src.utils.simulation.Simulation.notification_type","title":"<code>notification_type: int</code>  <code>property</code> <code>writable</code>","text":"<p>gets the notification type for the OnIdle handler.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The notification type. 0-Idle. 1-IdleU</p>"},{"location":"999_reference/#src.utils.simulation.Simulation.increment_time","title":"<code>increment_time(ticks)</code>","text":"<p>Increases the system time during the measurement in simulation mode. Whereas IncrementTime returns immediately after calling, the IncrementTimeAndWait function returns not until the simulation step is done in CANoe.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>The number of ticks by which the system time is to be increased. 1 tick corresponds to 10 \u00b5s.</p> required Source code in <code>src\\utils\\simulation.py</code> <pre><code>def increment_time(self, ticks: int) -&gt; None:\n\"\"\"Increases the system time during the measurement in simulation mode.\n    Whereas IncrementTime returns immediately after calling, the IncrementTimeAndWait function returns not until the simulation step is done in CANoe.\n\n    Args:\n        ticks (int): The number of ticks by which the system time is to be increased. 1 tick corresponds to 10 \u00b5s.\n    \"\"\"\n    self.sim_obj.IncrementTime(ticks)\n    self.log.info(f'Increased the system time to = {ticks} ticks.')\n</code></pre>"},{"location":"999_reference/#src.utils.simulation.Simulation.increment_time_and_wait","title":"<code>increment_time_and_wait(ticks)</code>","text":"<p>Increases the system time during the measurement in Simulation mode. Whereas IncrementTime returns immediately after calling, the IncrementTimeAndWait method returns not until the simulation step is done in CANoe.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>The number of ticks by which the system time is to be increased. 1 tick corresponds to 10 \u00b5s.</p> required Source code in <code>src\\utils\\simulation.py</code> <pre><code>def increment_time_and_wait(self, ticks: int) -&gt; None:\n\"\"\"Increases the system time during the measurement in Simulation mode.\n    Whereas IncrementTime returns immediately after calling, the IncrementTimeAndWait method returns not until the simulation step is done in CANoe.\n\n    Args:\n        ticks (int): The number of ticks by which the system time is to be increased. 1 tick corresponds to 10 \u00b5s.\n    \"\"\"\n    self.sim_obj.IncrementTimeAndWait(ticks)\n    self.log.info(f'Increased the system time to = {ticks} ticks.')\n</code></pre>"},{"location":"999_reference/#src.utils.system.Namespace","title":"<code>Namespace</code>","text":"Source code in <code>src\\utils\\system.py</code> <pre><code>class Namespace:\n    def __init__(self, namespace_com_obj: object) -&gt; None:\n        self.namespace_com_obj = namespace_com_obj\n\n    @property\n    def comment(self) -&gt; str:\n\"\"\"Gets the comment for the Namespace.\n\n        Returns:\n            str: The comment.\n        \"\"\"\n        return self.namespace_com_obj.Comment\n\n    @comment.setter\n    def comment(self, text: str) -&gt; None:\n\"\"\"Defines the comment for the Namespace.\n\n        Args:\n            text (str): The comment\n        \"\"\"\n        self.namespace_com_obj.Comment = text\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the name of the Namespace.\n\n        Returns:\n            str: The name of the namespace.\n        \"\"\"\n        return self.namespace_com_obj.Name\n\n    @property\n    def namespaces(self) -&gt; object:\n\"\"\"Returns the Namespaces object.\n\n        Returns:\n            object: The Namespaces object.\n        \"\"\"\n        return self.namespace_com_obj.Namespaces\n\n    @property\n    def variables(self) -&gt; object:\n\"\"\"Returns the Variables object.\n\n        Returns:\n            object: The Variables object.\n        \"\"\"\n        return self.namespace_com_obj.Variables\n</code></pre>"},{"location":"999_reference/#src.utils.system.Namespace.comment","title":"<code>comment: str</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the comment for the Namespace.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The comment.</p>"},{"location":"999_reference/#src.utils.system.Namespace.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the Namespace.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the namespace.</p>"},{"location":"999_reference/#src.utils.system.Namespace.namespaces","title":"<code>namespaces: object</code>  <code>property</code>","text":"<p>Returns the Namespaces object.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The Namespaces object.</p>"},{"location":"999_reference/#src.utils.system.Namespace.variables","title":"<code>variables: object</code>  <code>property</code>","text":"<p>Returns the Variables object.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The Variables object.</p>"},{"location":"999_reference/#src.utils.system.Namespaces","title":"<code>Namespaces</code>","text":"Source code in <code>src\\utils\\system.py</code> <pre><code>class Namespaces:\n    def __init__(self, namespaces_com_obj: object) -&gt; None:\n        self.namespaces_com_obj = namespaces_com_obj\n\n    @property\n    def count(self) -&gt; int:\n        return self.namespaces_com_obj.Count\n\n    def add(self, name: str) -&gt; object:\n\"\"\"Adds a new namespace.\n\n        Args:\n            name (str): The name of the new namespace.\n\n        Returns:\n            object: The new Namespace object.\n        \"\"\"\n        return self.namespaces_com_obj.Add(name)\n\n    def remove(self, name: str) -&gt; None:\n\"\"\"Removes an Namespace from a group\n\n        Args:\n            name (str): A Namespace object.\n        \"\"\"\n        self.namespaces_com_obj.Remove(name)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Namespaces.add","title":"<code>add(name)</code>","text":"<p>Adds a new namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the new namespace.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Namespace object.</p> Source code in <code>src\\utils\\system.py</code> <pre><code>def add(self, name: str) -&gt; object:\n\"\"\"Adds a new namespace.\n\n    Args:\n        name (str): The name of the new namespace.\n\n    Returns:\n        object: The new Namespace object.\n    \"\"\"\n    return self.namespaces_com_obj.Add(name)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Namespaces.remove","title":"<code>remove(name)</code>","text":"<p>Removes an Namespace from a group</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A Namespace object.</p> required Source code in <code>src\\utils\\system.py</code> <pre><code>def remove(self, name: str) -&gt; None:\n\"\"\"Removes an Namespace from a group\n\n    Args:\n        name (str): A Namespace object.\n    \"\"\"\n    self.namespaces_com_obj.Remove(name)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variable","title":"<code>Variable</code>","text":"Source code in <code>src\\utils\\system.py</code> <pre><code>class Variable:\n    def __init__(self, variable_com_obj) -&gt; None:\n        self.variable_com_obj = variable_com_obj\n\n    @property\n    def analysis_only(self) -&gt; bool:\n\"\"\"Determines if the variable shall be only used for analysis purposes or not.\n\n        Returns:\n            bool: false (default) ,true\n        \"\"\"\n        return self.variable_com_obj.AnalysisOnly\n\n    @analysis_only.setter\n    def analysis_only(self, value: bool) -&gt; None:\n\"\"\"sets if the variable shall be only used for analysis purposes or not.\n        If the property is set to false (default value), it may still be changed to analysis only in a CAPL program.\n\n        Args:\n            value (bool): false (default) ,true.\n        \"\"\"\n        self.variable_com_obj.AnalysisOnly = value\n\n    @property\n    def bit_count(self) -&gt; int:\n\"\"\"Returns the number of bits of the variable data type.\n\n        Returns:\n            int: The number of bits of the variable data type.\n        \"\"\"\n        return self.variable_com_obj.BitCount\n\n    @property\n    def comment(self) -&gt; str:\n\"\"\"Gets the comment for the variable..\n\n        Returns:\n            str: The comment.\n        \"\"\"\n        return self.variable_com_obj.Comment\n\n    @comment.setter\n    def comment(self, text: str) -&gt; None:\n\"\"\"defines the comment for the variable.\n\n        Args:\n            text (str): The comment\n        \"\"\"\n        self.variable_com_obj.Comment = text\n\n    @property\n    def element_count(self) -&gt; int:\n\"\"\"For arrays: the maximum number of elements in the array.\n\n        Returns:\n            int: The maximum number of elements in the array.\n        \"\"\"\n        return self.variable_com_obj.ElementCount\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"determines the complete path of the variable.\n\n        Returns:\n            str: The full name, including namespace, variable name and member name.\n        \"\"\"\n        return self.variable_com_obj.FullName\n\n    @full_name.setter\n    def full_name(self, full_name: str) -&gt; None:\n\"\"\"sets the complete path of the variable.\n\n        Args:\n            full_name (str): The new complete path of the object.\n        \"\"\"\n        self.variable_com_obj.FullName = full_name\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the name of the variable.\n\n        Returns:\n            str: The name of the system variable.\n        \"\"\"\n        return self.variable_com_obj.Name\n\n    @property\n    def init_value(self) -&gt; tuple[int, float, str]:\n\"\"\"The initial value of the variable.\n\n        Returns:\n            tuple[int, float, str]: The initial value of the variable.\n        \"\"\"\n        return self.variable_com_obj.InitValue\n\n    @property\n    def min_value(self) -&gt; tuple[int, float, str]:\n\"\"\"Returns the minimum value of the object.\n\n        Returns:\n            tuple[int, float, str]: minimum value of the variable.\n        \"\"\"\n        return self.variable_com_obj.MinValue\n\n    @property\n    def max_value(self) -&gt; tuple[int, float, str]:\n\"\"\"Returns the maximum value of the variable.\n\n        Returns:\n            tuple[int, float, str]: The maximum value of the variable.\n        \"\"\"\n        return self.variable_com_obj.MaxValue\n\n    @property\n    def is_array(self) -&gt; bool:\n\"\"\"Whether the variable data type is an array.\n\n        Returns:\n            bool: Whether the variable data type is an array.\n        \"\"\"\n        return self.variable_com_obj.IsArray\n\n    @property\n    def is_signed(self) -&gt; bool:\n\"\"\"For integer variables: whether the data type is signed.\n\n        Returns:\n            bool: Whether the data type is signed.\n        \"\"\"\n        return self.variable_com_obj.IsSigned\n\n    @property\n    def read_only(self) -&gt; bool:\n\"\"\"Indicates whether the system variable is write protected.\n\n        Returns:\n            bool: If the variable is write protected True is returned; otherwise False is returned.\n        \"\"\"\n        return self.variable_com_obj.ReadOnly\n\n    @property\n    def type(self) -&gt; int:\n\"\"\"Returns the type of a system variable.\n\n        Returns:\n            int: The type of the system variable. The following types are define- 0: Integer 1: Float 2: String 4: Float Array 5: Integer Array 6: LongLong 7: Byte Array 98: Generic Array 99: Struct 65535: Invalid\n        \"\"\"\n        return self.variable_com_obj.Type\n\n    @property\n    def unit(self) -&gt; str:\n\"\"\"Returns the unit of the variable.\n\n        Returns:\n            str: The unit of the variable.\n        \"\"\"\n        return self.variable_com_obj.Unit\n\n    @property\n    def value(self) -&gt; tuple[int, float, str]:\n\"\"\"Defines or sets the active value of the variable.\n\n        Returns:\n            tuple[int, float, str]: The value of the variable.\n        \"\"\"\n        return self.variable_com_obj.Value\n\n    @value.setter\n    def value(self, value: tuple[int, float, str]) -&gt; None:\n\"\"\"Defines or sets the active value of the variable.\n\n        Args:\n            value (tuple[int, float, str]): The new value of the variable.\n        \"\"\"\n        self.variable_com_obj.Value = value\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variable.analysis_only","title":"<code>analysis_only: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Determines if the variable shall be only used for analysis purposes or not.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>false (default) ,true</p>"},{"location":"999_reference/#src.utils.system.Variable.bit_count","title":"<code>bit_count: int</code>  <code>property</code>","text":"<p>Returns the number of bits of the variable data type.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of bits of the variable data type.</p>"},{"location":"999_reference/#src.utils.system.Variable.comment","title":"<code>comment: str</code>  <code>property</code> <code>writable</code>","text":"<p>Gets the comment for the variable..</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The comment.</p>"},{"location":"999_reference/#src.utils.system.Variable.element_count","title":"<code>element_count: int</code>  <code>property</code>","text":"<p>For arrays: the maximum number of elements in the array.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The maximum number of elements in the array.</p>"},{"location":"999_reference/#src.utils.system.Variable.full_name","title":"<code>full_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>determines the complete path of the variable.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full name, including namespace, variable name and member name.</p>"},{"location":"999_reference/#src.utils.system.Variable.init_value","title":"<code>init_value: tuple[int, float, str]</code>  <code>property</code>","text":"<p>The initial value of the variable.</p> <p>Returns:</p> Type Description <code>tuple[int, float, str]</code> <p>tuple[int, float, str]: The initial value of the variable.</p>"},{"location":"999_reference/#src.utils.system.Variable.is_array","title":"<code>is_array: bool</code>  <code>property</code>","text":"<p>Whether the variable data type is an array.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the variable data type is an array.</p>"},{"location":"999_reference/#src.utils.system.Variable.is_signed","title":"<code>is_signed: bool</code>  <code>property</code>","text":"<p>For integer variables: whether the data type is signed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the data type is signed.</p>"},{"location":"999_reference/#src.utils.system.Variable.max_value","title":"<code>max_value: tuple[int, float, str]</code>  <code>property</code>","text":"<p>Returns the maximum value of the variable.</p> <p>Returns:</p> Type Description <code>tuple[int, float, str]</code> <p>tuple[int, float, str]: The maximum value of the variable.</p>"},{"location":"999_reference/#src.utils.system.Variable.min_value","title":"<code>min_value: tuple[int, float, str]</code>  <code>property</code>","text":"<p>Returns the minimum value of the object.</p> <p>Returns:</p> Type Description <code>tuple[int, float, str]</code> <p>tuple[int, float, str]: minimum value of the variable.</p>"},{"location":"999_reference/#src.utils.system.Variable.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the variable.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the system variable.</p>"},{"location":"999_reference/#src.utils.system.Variable.read_only","title":"<code>read_only: bool</code>  <code>property</code>","text":"<p>Indicates whether the system variable is write protected.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the variable is write protected True is returned; otherwise False is returned.</p>"},{"location":"999_reference/#src.utils.system.Variable.type","title":"<code>type: int</code>  <code>property</code>","text":"<p>Returns the type of a system variable.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The type of the system variable. The following types are define- 0: Integer 1: Float 2: String 4: Float Array 5: Integer Array 6: LongLong 7: Byte Array 98: Generic Array 99: Struct 65535: Invalid</p>"},{"location":"999_reference/#src.utils.system.Variable.unit","title":"<code>unit: str</code>  <code>property</code>","text":"<p>Returns the unit of the variable.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unit of the variable.</p>"},{"location":"999_reference/#src.utils.system.Variable.value","title":"<code>value: tuple[int, float, str]</code>  <code>property</code> <code>writable</code>","text":"<p>Defines or sets the active value of the variable.</p> <p>Returns:</p> Type Description <code>tuple[int, float, str]</code> <p>tuple[int, float, str]: The value of the variable.</p>"},{"location":"999_reference/#src.utils.system.Variables","title":"<code>Variables</code>","text":"Source code in <code>src\\utils\\system.py</code> <pre><code>class Variables:\n    def __init__(self, variables_com_obj) -&gt; None:\n        self.variables_com_obj = variables_com_obj\n\n    @property\n    def count(self) -&gt; int:\n\"\"\"Returns the number of Variable objects inside the collection.\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.variables_com_obj.Count\n\n    def add(self, name: str, initial_value=0) -&gt; object:\n\"\"\"Adds a new read-only variable.\n\n        Args:\n            name (str): The name of the new variable.\n            initial_value (int): The initial value of the new variable. default value: 0 (Integer).\n\n        Returns:\n            object: The new Variable object.\n        \"\"\"\n        return self.variables_com_obj.Add(name, initial_value)\n\n    def add_ex(self, name: str, initial_value=0, min_value=0, max_value=0) -&gt; object:\n\"\"\"Adds a new read-only variable.\n\n        Args:\n            name (str): The name of the new variable.\n            initial_value (int, optional): The initial value of the new variable. Defaults to 0.\n            min_value (int, optional): The minimum value of the new variable. Defaults to 0.\n            max_value (int, optional): The maximum value of the new variable. Defaults to 0.\n\n        Returns:\n            object: The new Variable object.\n        \"\"\"\n        return self.variables_com_obj.AddEx(name, initial_value, min_value, max_value)\n\n    def add_writable(self, name: str, initial_value=0) -&gt; object:\n\"\"\"Adds a new writable variable.\n\n        Args:\n            name (str): The name of the new variable.\n            initial_value (int): The initial value of the new variable. default value: 0 (Integer).\n\n        Returns:\n            object: The new Variable object.\n        \"\"\"\n        return self.variables_com_obj.AddWriteable(name, initial_value)\n\n    def add_writable_ex(self, name: str, initial_value=0, min_value=0, max_value=0) -&gt; object:\n\"\"\"Adds a new writable variable.\n\n        Args:\n            name (str): The name of the new variable.\n            initial_value (int, optional): The initial value of the new variable. Defaults to 0.\n            min_value (int, optional): The minimum value of the new variable. Defaults to 0.\n            max_value (int, optional): The maximum value of the new variable. Defaults to 0.\n\n        Returns:\n            object: The new Variable object.\n        \"\"\"\n        return self.variables_com_obj.AddWritableEx(name, initial_value, min_value, max_value)\n\n    def remove(self, variable: object) -&gt; None:\n\"\"\"Removes variable from a group\n\n        Args:\n            variable (str): Variable object.\n        \"\"\"\n        self.variables_com_obj.Remove(variable)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variables.count","title":"<code>count: int</code>  <code>property</code>","text":"<p>Returns the number of Variable objects inside the collection.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p>"},{"location":"999_reference/#src.utils.system.Variables.add","title":"<code>add(name, initial_value=0)</code>","text":"<p>Adds a new read-only variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the new variable.</p> required <code>initial_value</code> <code>int</code> <p>The initial value of the new variable. default value: 0 (Integer).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Variable object.</p> Source code in <code>src\\utils\\system.py</code> <pre><code>def add(self, name: str, initial_value=0) -&gt; object:\n\"\"\"Adds a new read-only variable.\n\n    Args:\n        name (str): The name of the new variable.\n        initial_value (int): The initial value of the new variable. default value: 0 (Integer).\n\n    Returns:\n        object: The new Variable object.\n    \"\"\"\n    return self.variables_com_obj.Add(name, initial_value)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variables.add_ex","title":"<code>add_ex(name, initial_value=0, min_value=0, max_value=0)</code>","text":"<p>Adds a new read-only variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the new variable.</p> required <code>initial_value</code> <code>int</code> <p>The initial value of the new variable. Defaults to 0.</p> <code>0</code> <code>min_value</code> <code>int</code> <p>The minimum value of the new variable. Defaults to 0.</p> <code>0</code> <code>max_value</code> <code>int</code> <p>The maximum value of the new variable. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Variable object.</p> Source code in <code>src\\utils\\system.py</code> <pre><code>def add_ex(self, name: str, initial_value=0, min_value=0, max_value=0) -&gt; object:\n\"\"\"Adds a new read-only variable.\n\n    Args:\n        name (str): The name of the new variable.\n        initial_value (int, optional): The initial value of the new variable. Defaults to 0.\n        min_value (int, optional): The minimum value of the new variable. Defaults to 0.\n        max_value (int, optional): The maximum value of the new variable. Defaults to 0.\n\n    Returns:\n        object: The new Variable object.\n    \"\"\"\n    return self.variables_com_obj.AddEx(name, initial_value, min_value, max_value)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variables.add_writable","title":"<code>add_writable(name, initial_value=0)</code>","text":"<p>Adds a new writable variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the new variable.</p> required <code>initial_value</code> <code>int</code> <p>The initial value of the new variable. default value: 0 (Integer).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Variable object.</p> Source code in <code>src\\utils\\system.py</code> <pre><code>def add_writable(self, name: str, initial_value=0) -&gt; object:\n\"\"\"Adds a new writable variable.\n\n    Args:\n        name (str): The name of the new variable.\n        initial_value (int): The initial value of the new variable. default value: 0 (Integer).\n\n    Returns:\n        object: The new Variable object.\n    \"\"\"\n    return self.variables_com_obj.AddWriteable(name, initial_value)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variables.add_writable_ex","title":"<code>add_writable_ex(name, initial_value=0, min_value=0, max_value=0)</code>","text":"<p>Adds a new writable variable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the new variable.</p> required <code>initial_value</code> <code>int</code> <p>The initial value of the new variable. Defaults to 0.</p> <code>0</code> <code>min_value</code> <code>int</code> <p>The minimum value of the new variable. Defaults to 0.</p> <code>0</code> <code>max_value</code> <code>int</code> <p>The maximum value of the new variable. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The new Variable object.</p> Source code in <code>src\\utils\\system.py</code> <pre><code>def add_writable_ex(self, name: str, initial_value=0, min_value=0, max_value=0) -&gt; object:\n\"\"\"Adds a new writable variable.\n\n    Args:\n        name (str): The name of the new variable.\n        initial_value (int, optional): The initial value of the new variable. Defaults to 0.\n        min_value (int, optional): The minimum value of the new variable. Defaults to 0.\n        max_value (int, optional): The maximum value of the new variable. Defaults to 0.\n\n    Returns:\n        object: The new Variable object.\n    \"\"\"\n    return self.variables_com_obj.AddWritableEx(name, initial_value, min_value, max_value)\n</code></pre>"},{"location":"999_reference/#src.utils.system.Variables.remove","title":"<code>remove(variable)</code>","text":"<p>Removes variable from a group</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>Variable object.</p> required Source code in <code>src\\utils\\system.py</code> <pre><code>def remove(self, variable: object) -&gt; None:\n\"\"\"Removes variable from a group\n\n    Args:\n        variable (str): Variable object.\n    \"\"\"\n    self.variables_com_obj.Remove(variable)\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Ui","title":"<code>Ui</code>","text":"<p>The UI object represents the user interface in CANoe.</p> Source code in <code>src\\utils\\ui.py</code> <pre><code>class Ui:\n\"\"\"The UI object represents the user interface in CANoe.\n    \"\"\"\n    def __init__(self, app) -&gt; None:\n        self.app = app\n        self.log = self.app.log\n        self.ui_com_obj = win32com.client.Dispatch(self.app.app_com_obj.UI)\n\n    @property\n    def command_enabled(self, command: str) -&gt; bool:\n\"\"\"defines the availability of a command on the user interface.\n\n        Args:\n            command (str): The command. If no command is entered the function acts on all commands that can be influenced via this interface.\n\n        Returns:\n            bool: The availability of the command: If the command is available True is returned. Otherwise False is returned.\n        \"\"\"\n        return self.ui_com_obj.CommandEnabled(command)\n\n    @command_enabled.setter\n    def command_enabled(self, command: str, value: bool) -&gt; None:\n\"\"\"sets the availability of a command on the user interface.\n\n        Args:\n            command (str): The command. If no command is entered the function acts on all commands that can be influenced via this interface.\n            value (bool): A boolean value that indicates whether the command should be available. Possible values are: True: The command is available. False: The command is not available.\n        \"\"\"\n        ce_obj = self.ui_com_obj.CommandEnabled(command)\n        ce_obj = value\n        self.log.info(f'enabled command {command}.')\n\n    def activate_desktop(self, name: str) -&gt; None:\n\"\"\"Activates the desktop with the given name.\n\n        Args:\n            name (str): The name of the desktop to be activated.\n        \"\"\"\n        self.ui_com_obj.ActivateDesktop(name)\n        self.log.info(f'Activated the desktop with the given name({name}.')\n\n    def open_baudrate_dialog(self) -&gt; None:\n\"\"\"Configures the bus parameters.\n        \"\"\"\n        self.ui_com_obj.OpenBaudrateDialog()\n        self.log.info(f'baudrate dialog opened. Configure the bus parameters.')\n\n    def get_write_window_text_content(self) -&gt; str:\n        write_obj = Write(self)\n        return write_obj.text\n\n    def clear_write_window_content(self) -&gt; None:\n        write_obj = Write(self)\n        write_obj.clear()\n\n    def copy_write_window_content_to_clipboard(self) -&gt; None:\n        write_obj = Write(self)\n        write_obj.copy()\n\n    def disable_write_window_logging(self, tab_index=None) -&gt; None:\n        write_obj = Write(self)\n        write_obj.disable_output_file(tab_index)\n\n    def enable_write_window_logging(self, output_file: str, tab_index=None) -&gt; None:\n        write_obj = Write(self)\n        write_obj.enable_output_file(output_file, tab_index)\n\n    def send_text_to_write_window(self, text: str) -&gt; None:\n        write_obj = Write(self)\n        write_obj.output(text)\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Ui.command_enabled","title":"<code>command_enabled: bool</code>  <code>property</code> <code>writable</code>","text":"<p>defines the availability of a command on the user interface.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command. If no command is entered the function acts on all commands that can be influenced via this interface.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The availability of the command: If the command is available True is returned. Otherwise False is returned.</p>"},{"location":"999_reference/#src.utils.ui.Ui.activate_desktop","title":"<code>activate_desktop(name)</code>","text":"<p>Activates the desktop with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the desktop to be activated.</p> required Source code in <code>src\\utils\\ui.py</code> <pre><code>def activate_desktop(self, name: str) -&gt; None:\n\"\"\"Activates the desktop with the given name.\n\n    Args:\n        name (str): The name of the desktop to be activated.\n    \"\"\"\n    self.ui_com_obj.ActivateDesktop(name)\n    self.log.info(f'Activated the desktop with the given name({name}.')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Ui.open_baudrate_dialog","title":"<code>open_baudrate_dialog()</code>","text":"<p>Configures the bus parameters.</p> Source code in <code>src\\utils\\ui.py</code> <pre><code>def open_baudrate_dialog(self) -&gt; None:\n\"\"\"Configures the bus parameters.\n    \"\"\"\n    self.ui_com_obj.OpenBaudrateDialog()\n    self.log.info(f'baudrate dialog opened. Configure the bus parameters.')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Write","title":"<code>Write</code>","text":"<p>The Write object represents the Write Window in CANoe. It is part of the user interface.</p> Source code in <code>src\\utils\\ui.py</code> <pre><code>class Write:\n\"\"\"The Write object represents the Write Window in CANoe.\n    It is part of the user interface.\n    \"\"\"\n    def __init__(self, ui_obj) -&gt; None:\n        self.ui_obj = ui_obj\n        self.log = self.ui_obj.log\n        self.write_com_obj = win32com.client.Dispatch(self.ui_obj.ui_com_obj.Write)\n\n    @property\n    def text(self) -&gt; str:\n\"\"\"Gets the text contents of the Write window.\n\n        Returns:\n            str: The text content\n        \"\"\"\n        return self.write_com_obj.Text\n\n    def clear(self) -&gt; None:\n\"\"\"Clears the contents of the Write Window\n        \"\"\"\n        self.write_com_obj.Clear()\n        self.log.info(f'Cleared the contents of the Write Window.')\n\n    def copy(self) -&gt; None:\n\"\"\"Copies the contents of the Write Window to the clipboard.\n        \"\"\"\n        self.write_com_obj.Copy()\n        self.log.info(f'Copied the contents of the Write Window to the clipboard.')\n\n    def disable_output_file(self, tab_index=None) -&gt; None:\n\"\"\"Disables logging of all outputs of the Write Window for the certain page.\n\n        Args:\n            tab_index (int, optional): The index of the tab, for which logging of the output is to be deactivated. Defaults to None.\n        \"\"\"\n        if tab_index:\n            self.write_com_obj.DisableOutputFile(tab_index)\n        else:\n            self.write_com_obj.DisableOutputFile()\n        self.log.info(f'Disabled logging of outputs of the Write Window. tab_index={tab_index}')\n\n    def enable_output_file(self, output_file: str, tab_index=None) -&gt; None:\n\"\"\"Enables logging of all outputs of the Write Window in the output file for the certain page.\n\n        Args:\n            output_file (str, optional): The complete path of the output file. Defaults to None.\n            tab_index (int, optional): The index of the page, for which logging of the output is to be activated. Defaults to None.\n        \"\"\"\n        if tab_index:\n            self.write_com_obj.EnableOutputFile(output_file, tab_index)\n        else:\n            self.write_com_obj.EnableOutputFile(output_file)\n        self.log.info(f'Enabled logging of outputs of the Write Window. output_file={output_file} and tab_index={tab_index}')\n\n    def output(self, text: str) -&gt; None:\n\"\"\"Outputs a line of text in the Write Window.\n\n        Args:\n            text (str): The text\n        \"\"\"\n        self.write_com_obj.Output(text)\n        self.log.info(f'Outputed {text} in the Write Window.')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Write.text","title":"<code>text: str</code>  <code>property</code>","text":"<p>Gets the text contents of the Write window.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text content</p>"},{"location":"999_reference/#src.utils.ui.Write.clear","title":"<code>clear()</code>","text":"<p>Clears the contents of the Write Window</p> Source code in <code>src\\utils\\ui.py</code> <pre><code>def clear(self) -&gt; None:\n\"\"\"Clears the contents of the Write Window\n    \"\"\"\n    self.write_com_obj.Clear()\n    self.log.info(f'Cleared the contents of the Write Window.')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Write.copy","title":"<code>copy()</code>","text":"<p>Copies the contents of the Write Window to the clipboard.</p> Source code in <code>src\\utils\\ui.py</code> <pre><code>def copy(self) -&gt; None:\n\"\"\"Copies the contents of the Write Window to the clipboard.\n    \"\"\"\n    self.write_com_obj.Copy()\n    self.log.info(f'Copied the contents of the Write Window to the clipboard.')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Write.disable_output_file","title":"<code>disable_output_file(tab_index=None)</code>","text":"<p>Disables logging of all outputs of the Write Window for the certain page.</p> <p>Parameters:</p> Name Type Description Default <code>tab_index</code> <code>int</code> <p>The index of the tab, for which logging of the output is to be deactivated. Defaults to None.</p> <code>None</code> Source code in <code>src\\utils\\ui.py</code> <pre><code>def disable_output_file(self, tab_index=None) -&gt; None:\n\"\"\"Disables logging of all outputs of the Write Window for the certain page.\n\n    Args:\n        tab_index (int, optional): The index of the tab, for which logging of the output is to be deactivated. Defaults to None.\n    \"\"\"\n    if tab_index:\n        self.write_com_obj.DisableOutputFile(tab_index)\n    else:\n        self.write_com_obj.DisableOutputFile()\n    self.log.info(f'Disabled logging of outputs of the Write Window. tab_index={tab_index}')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Write.enable_output_file","title":"<code>enable_output_file(output_file, tab_index=None)</code>","text":"<p>Enables logging of all outputs of the Write Window in the output file for the certain page.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str</code> <p>The complete path of the output file. Defaults to None.</p> required <code>tab_index</code> <code>int</code> <p>The index of the page, for which logging of the output is to be activated. Defaults to None.</p> <code>None</code> Source code in <code>src\\utils\\ui.py</code> <pre><code>def enable_output_file(self, output_file: str, tab_index=None) -&gt; None:\n\"\"\"Enables logging of all outputs of the Write Window in the output file for the certain page.\n\n    Args:\n        output_file (str, optional): The complete path of the output file. Defaults to None.\n        tab_index (int, optional): The index of the page, for which logging of the output is to be activated. Defaults to None.\n    \"\"\"\n    if tab_index:\n        self.write_com_obj.EnableOutputFile(output_file, tab_index)\n    else:\n        self.write_com_obj.EnableOutputFile(output_file)\n    self.log.info(f'Enabled logging of outputs of the Write Window. output_file={output_file} and tab_index={tab_index}')\n</code></pre>"},{"location":"999_reference/#src.utils.ui.Write.output","title":"<code>output(text)</code>","text":"<p>Outputs a line of text in the Write Window.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text</p> required Source code in <code>src\\utils\\ui.py</code> <pre><code>def output(self, text: str) -&gt; None:\n\"\"\"Outputs a line of text in the Write Window.\n\n    Args:\n        text (str): The text\n    \"\"\"\n    self.write_com_obj.Output(text)\n    self.log.info(f'Outputed {text} in the Write Window.')\n</code></pre>"},{"location":"999_reference/#src.utils.version.Version","title":"<code>Version</code>","text":"<p>The Version object represents the version of the CANoe application.</p> Source code in <code>src\\utils\\version.py</code> <pre><code>class Version:\n\"\"\"The Version object represents the version of the CANoe application.\n    \"\"\"\n    def __init__(self, app_obj) -&gt; None:\n        self.app_obj = app_obj\n        self.log = self.app_obj.log\n        self.ver_obj = win32com.client.Dispatch(self.app_obj.app_com_obj.Version)\n\n    @property\n    def build(self) -&gt; int:\n\"\"\"Returns the build number of the CANoe application.\n\n        Returns:\n            int: The build number of the CANoe application.\n        \"\"\"\n        return self.ver_obj.Build\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"Determines the complete path of the object.\n\n        Returns:\n            str: The complete CANoe version in the following format: \"Vector CANoe /run 6.0.50\" or \"Vector CANoe.LIN /run 6.0.50\".\n        \"\"\"\n        return self.ver_obj.FullName\n\n    @full_name.setter\n    def full_name(self, full_name: str) -&gt; None:\n\"\"\"Sets the complete path of the object.\n\n        Args:\n            full_name (str): The complete CANoe version in the following format: \"Vector CANoe /run 6.0.50\" or \"Vector CANoe.LIN /run 6.0.50\".\n        \"\"\"\n        self.ver_obj.FullName = full_name\n        self.log.info(f'CANoe version set to {full_name}.')\n\n    @property\n    def major(self) -&gt; int:\n\"\"\"Returns the major version number of the CANoe application.\n\n        Returns:\n            int: The major version number of the CANoe application.\n        \"\"\"\n        return self.ver_obj.major\n\n    @property\n    def minor(self) -&gt; int:\n\"\"\"Returns the Minor version number of the CANoe application.\n\n        Returns:\n            int: The Minor version number of the CANoe application.\n        \"\"\"\n        return self.ver_obj.minor\n\n    @property\n    def name(self) -&gt; str:\n\"\"\"Returns the name of the object.\n\n        Returns:\n            str: The CANoe version in the following format: \"CANoe 5.1 SP2\" (with Service Pack) or \"CANoe.LIN 5.1\" (without Service Pack).\n        \"\"\"\n        return self.ver_obj.Name\n\n    @property\n    def patch(self) -&gt; int:\n\"\"\"Returns the patch number of the CANoe application.\n\n        Returns:\n            int: The patch number of the CANoe application.\n        \"\"\"\n        return self.ver_obj.Patch\n</code></pre>"},{"location":"999_reference/#src.utils.version.Version.build","title":"<code>build: int</code>  <code>property</code>","text":"<p>Returns the build number of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The build number of the CANoe application.</p>"},{"location":"999_reference/#src.utils.version.Version.full_name","title":"<code>full_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Determines the complete path of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The complete CANoe version in the following format: \"Vector CANoe /run 6.0.50\" or \"Vector CANoe.LIN /run 6.0.50\".</p>"},{"location":"999_reference/#src.utils.version.Version.major","title":"<code>major: int</code>  <code>property</code>","text":"<p>Returns the major version number of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The major version number of the CANoe application.</p>"},{"location":"999_reference/#src.utils.version.Version.minor","title":"<code>minor: int</code>  <code>property</code>","text":"<p>Returns the Minor version number of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The Minor version number of the CANoe application.</p>"},{"location":"999_reference/#src.utils.version.Version.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Returns the name of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The CANoe version in the following format: \"CANoe 5.1 SP2\" (with Service Pack) or \"CANoe.LIN 5.1\" (without Service Pack).</p>"},{"location":"999_reference/#src.utils.version.Version.patch","title":"<code>patch: int</code>  <code>property</code>","text":"<p>Returns the patch number of the CANoe application.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The patch number of the CANoe application.</p>"}]}